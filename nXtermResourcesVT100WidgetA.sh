#!/bin/bash
 a="\e[1;32m+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\e[0m"
 b="\e[1;32m+--------------------------------------------------------------------------------+\e[0m"
#c
#d
#e
function menu {
clear
tput cup 0 0; echo -e "$a"
tput cup 1 0
 for (( c=0; c<=36; c++ ))
  do
   echo -e "\e[1;32m|                                                                                |\e[0m"
  done
#
tput cup  1  1;echo -e "\e[1;36m VT100 Widget Resources \e[0m\e[36m Ресурсы виджетов VT100\e[0m                           - A -"
tput cup  2  0;echo -e "$b"
tput cup  3  2;echo -e "Следующие ресурсы указаны как часть виджета vt100 (класс VT100)."
tput cup  4  2;echo -e "Они задаются шаблонами, такими как «XTerm.vt100.NAME»."
tput cup  5  2;echo -e "Если ваш xterm настроен на поддержку «панели инструментов», то этим шаблонам"
tput cup  6  2;echo -e "требуется дополнительный уровень для виджета формы, который содержит панель"
tput cup  7  2;echo -e "инструментов и виджет vt100. Подстановочный знак между виджетом «XTerm»"
tput cup  8  2;echo -e "верхнего уровня и виджетом «vt100» заставляет настройки ресурса работать для"
tput cup  9  2;echo -e "любого из них, например, «XTerm*vt100.NAME»"
tput cup 10  0;echo -e "$b"
tput cup 11  1;echo -e "\e[33m [1]\e[0m Использовать ли активные окна значков при отображении окна     \e[32m activeIcon\e[0m"
tput cup 12  1;echo -e "\e[33m [2]\e[0m Установлено «false», xterm не будет полужирный шрифт       \e[32m allowBoldFonts\e[0m"
tput cup 13  1;echo -e "\e[33m [3]\e[0m Значение true, переопределяет C1 (коды 128–159)          \e[32m allowC1Printable\e[0m"
tput cup 14  1;echo -e "\e[33m [4]\e[0m Устанавливают/запрашивают динамические цвета                \e[32m allowColorOps\e[0m"
tput cup 15  1;echo -e "\e[33m [5]\e[0m Последовательности, устанавливают/запрашивают шрифт          \e[32m allowFontOps\e[0m"
tput cup 16  1;echo -e "\e[33m [6]\e[0m Определяет xterm отправлять escape-последовательности       \e[32m allowMouseOps\e[0m"
tput cup 17  1;echo -e "\e[33m [7]\e[0m Если true, разрешить вставку управляющих символов      \e[32m allowPasteControls\e[0m"
tput cup 18  1;echo -e "\e[33m [8]\e[0m Указывает, устанавливают/запрашивают клавишу Scroll Lock  \e[32m allowScrollLock\e[0m"
tput cup 19  1;echo -e "\e[33m [9]\e[0m Интерпретировать ли/отбрасывать события клавиш/кнопок     \e[32m allowSendEvents\e[0m"
tput cup 20  1;echo -e "\e[33m [a]\e[0m Должны ли быть разрешены управляющие последовательности      \e[32m allowTcapOps\e[0m"
tput cup 21  1;echo -e "\e[33m [b]\e[0m Последовательности, изменяющие заголовок окна/имя значка    \e[32m allowTitleOps\e[0m"
tput cup 22  1;echo -e "\e[33m [c]\e[0m Разрешить расширенные последовательности управления окном  \e[32m allowWindowOps\e[0m"
tput cup 23  1;echo -e "\e[33m [d]\e[0m True, обрабатывать Alt-клавишу, как если это мета-клавиша    \e[32m altIsNotMeta\e[0m"
tput cup 24  1;echo -e "\e[33m [e]\e[0m Операция может выполняться после логики для metaSendsEscape\e[32m altSendsEscape\e[0m"
tput cup 25  1;echo -e "\e[33m [f]\e[0m Действия «прокрутка назад» и «прокрутка вперед»           \e[32m alternateScroll\e[0m"
tput cup 26  1;echo -e "\e[33m [g]\e[0m Проверять, различаются ли обычный и полужирный шрифты      \e[32m alwaysBoldMode\e[0m"
tput cup 27  1;echo -e "\e[33m [h]\e[0m Указывает всегда отображать выделенный текстовый курсор   \e[32m alwaysHighlight\e[0m"
tput cup 28  1;echo -e "\e[33m [i]\e[0m указав xterm использовать модификаторы Alt и Meta           \e[32m alwaysUseMods\e[0m"
tput cup 29  1;echo -e "\e[33m [j]\e[0m отправляет в ответ на символ ENQ (control/E) от хоста    \e[32m answerbackString\e[0m"
tput cup 30  1;echo -e "\e[33m [k]\e[0m клавиши управления курсором находятся в режиме приложения\e[32m appcursorDefault\e[0m"
tput cup 31  1;echo -e "\e[33m [l]\e[0m клавиши клавиатуры находятся в режиме приложения         \e[32m appkeypadDefault\e[0m"
tput cup 32  1;echo -e "\e[33m [m]\e[0m «true», это включает особый случай растровых шрифтов       \e[32m assumeAllChars\e[0m"
tput cup 33  0;echo -e "$b"
#
tput cup 35  0;echo -e "$b"
tput cup 36  1;echo -e "\e[33m [n]\e[0m Далее                                                                \e[32m Next\e[0m"
tput cup 37  1;echo -e "\e[33m [0]\e[0m Exit"
tput cup 38  0;echo -e "$a"
#
tput cup 34  1;echo -e "\e[33m [ ]\e[0m Ожидание ввода команды: "
tput cup 34 30;read -n 1 option
#
}
#menu software
while [ $? -ne 1 ]
do
menu
case $option in
0)
clear
exit 0
;;
1)load;clear;echo -e "
 (class ActiveIcon)
 Определяет, следует ли использовать активные окна значков при отображении окна
 xterm, если эта функция скомпилирована в xterm.
 Активный значок представляет собой миниатюрное представление содержимого окна
 и будет обновляться по мере изменения содержимого.
 Не все оконные менеджеры обязательно поддерживают окна значков приложений.
 Некоторые оконные менеджеры позволяют вводить нажатия клавиш в активное окно
 значка. По умолчанию стоит «default».
 Xterm принимает либо ключевое слово (без учета регистра), либо число,
 указанное в скобках:
\e[32m false  \e[0m Активный значок не отображается.
\e[32m true   \e[0m Отображается активный значок. Если вы используете twm,
         используйте этот параметр для включения активных значков.
\e[32m default\e[0m Xterm проверяет при запуске и показывает активный значок
         только для оконных менеджеров, которые он может идентифицировать
         и которые, как известно, поддерживают эту функцию.
         Это fvwm (полная поддержка) и оконный производитель (ограниченная).
         Несколько других оконных менеджеров (например, twm и ctwm) поддерживают
         активные значки, но не поддерживают расширения,
         позволяющие xterm идентифицировать оконный менеджер.
";;
2)load;clear;echo -e "
\e[32m allowBoldFonts\e[0m (class AllowBoldFonts)
 Если установлено значение «false», xterm не будет использовать полужирный шрифт.
 Это переопределяет как ресурсы alwaysBoldMode, так и ресурсы boldMode.
";;
3)load;clear;echo -e "
 allowC1Printable\e[0m (class AllowC1Printable)
 Если задано значение true, переопределяет сопоставление элементов управления C1
 (коды 128–159), чтобы они обрабатывались так, как если бы они были печатными
 символами. Хотя это не соответствует определенному стандарту, некоторые
 пользователи настаивают на том, что это VT100. По умолчанию «false».
";;
4)load;clear;echo -e "
\e[32m allowColorOps\e[0m (class AllowColorOps)
 Указывает, следует ли разрешать управляющие последовательности, которые
 устанавливают/запрашивают динамические цвета.
 Этот параметр ресурса не влияет на цвета ANSI.
 По умолчанию установлено значение «true».
";;
5)load;clear;echo -e "
\e[32m allowFontOps\e[0m (class AllowFontOps)
 Указывает, следует ли разрешать управляющие последовательности,
 которые устанавливают/запрашивают шрифт.
 По умолчанию установлено значение «true».
";;
6)load;clear;echo -e "
\e[32m allowMouseOps\e[0m (class AllowMouseOps)
 Определяет, будут ли управляющие последовательности, позволяющие xterm отправлять
 escape-последовательности на хост при щелчках мыши и перемещении.
 По умолчанию установлено значение «true».
";;
7)load;clear;echo -e "
\e[32m allowPasteControls\e[0m (class AllowPasteControls)
 Если true, разрешить вставку управляющих символов, таких как BEL и CAN.
 Символы форматирования (табуляции, новой строки) разрешены всегда.
 Другие управляющие символы C0 подавляются, если этот ресурс не включен.
 Точный набор управляющих символов (C0 и C1) зависит от того, используется ли
 кодировка UTF-8, а также от ресурса allowC1Printable. По умолчанию «false».
";;
8)load;clear;echo -e "
\e[32m allowScrollLock\e[0m (class AllowScrollLock)
 Указывает, следует ли разрешать управляющие последовательности, которые
 устанавливают/запрашивают клавишу Scroll Lock, а также отвечает ли клавиша
 Scroll Lock на нажатие клавиши пользователем. Значение по умолчанию — «false».,
 Определяет, должны ли быть разрешены управляющие последовательности, которые
 устанавливают/запрашивают клавишу Scroll Lock, а также отвечает ли клавиша
 Scroll Lock на нажатие клавиши пользователем.
 По умолчанию установлено значение «false».
";;
9)load;clear;echo -e "
\e[32m allowSendEvents\e[0m (class AllowSendEvents)
 Указывает, следует ли интерпретировать или отбрасывать искусственные события
 клавиш и кнопок (сгенерированные с использованием запроса SendEvent протокола X).
 По умолчанию установлено значение «false», что означает, что они отбрасываются.
 Обратите внимание, что разрешение таких событий создало бы очень большую дыру
 в безопасности, поэтому включение этого ресурса принудительно отключает
 ресурсы allowXXXOps. По умолчанию «false».
";;
a)load;clear;echo -e "
\e[32m allowTcapOps\e[0m (class AllowTcapOps)
 Определяет, должны ли быть разрешены управляющие последовательности,
 запрашивающие понятие терминала о его строках функциональных клавиш, такие как
 возможности termcap или terminfo. Значение по умолчанию — «true».
 Несколько программ, например, vim, используют эту функцию для получения точного
 описания возможностей терминала, независимо от настройки termcap/terminfo:
 • Xterm может сообщить запрашивающей программе, сколько цветов он поддерживает.
 Это константа, в зависимости от того, как она скомпилирована, обычно 16.
 Она не меняется, если вы изменяете настройки ресурса, например, ресурса boldColors.
 • Xterm может сообщить запрашивающей программе, какие строки отправляются
 с помощью модифицированных (shift, control, alt) функциональных клавиш и клавиш
 клавиатуры. Контроль отчетности и alt-modifiers
 — это функция, основанная на расширенном именовании ncurses.
";;
b)load;clear;echo -e "
\e[32m allowTitleOps\e[0m (class AllowTitleOps)
 Указывает, следует ли разрешать управляющие последовательности,
 изменяющие заголовок окна или имя значка.
 По умолчанию установлено значение «true».
";;
c)load;clear;echo -e "
\e[32m allowWindowOps\e[0m (class AllowWindowOps)
 Указывает, следует ли разрешить расширенные последовательности управления окном
 (используемые в dtterm). К ним относятся несколько управляющих последовательностей,
 которые манипулируют размером или положением окна, а также сообщают об этих
 значениях и имени заголовка или значка. Каждым из них можно злоупотреблять в
 сценарии; как ни странно, большинство эмуляторов терминалов, реализующих их,
 ограничивают лишь небольшую часть репертуара.
 Для тонкой настройки см. disallowedWindowOps. По умолчанию «false».
";;
d)load;clear;echo -e "
\e[32m altIsNotMeta\e[0m (class AltIsNotMeta)
 Если «true», обрабатывать Alt-клавишу, как если бы это была мета-клавиша.
 Ваша клавиатура может быть настроена таким образом, что они одинаковы.
 Но если это не так, это позволяет вам использовать те же префиксы и операции
 сдвига с клавишей Alt, что и с клавишей Meta.
 См. altSendsEscape и metaSendsEscape. По умолчанию «false».
";;
e)load;clear;echo -e "
\e[32m altSendsEscape\e[0m (class AltSendsEscape)
 Это дополнительная операция с клавиатурой, которая может выполняться после
 логики для metaSendsEscape.
 Он доступен, только если установлен ресурс altIsNotMeta:
 • Если установлено значение «true», символы Alt (символ в сочетании
 с модификатором, связанным с левой/правой клавишами Alt) преобразуются в
 двухсимвольную последовательность, в которой перед самим символом ставится ESC.
 Это также относится к последовательностям управления функциональными клавишами,
 если только xterm не увидит, что Alt используется в ваших переводах клавиш.
 • Если установлено значение «false», символы Alt, вводимые с клавиатуры,
 вызывают переход к 8-битным символам (точно так же, как в metaSendsEscape).
 Комбинируя Alt- и Meta-модификаторы, вы можете создавать соответствующие
 комбинации ESC-префикса и 8-битных символов.
 По умолчанию установлено значение «false».
 Xterm предоставляет пункт меню для переключения этого ресурса.
";;
f)load;clear;echo -e "
\e[32m alternateScroll\e[0m (class ScrollCond)
 Если установлено значение «true», действия «прокрутка назад» и «прокрутка вперед»
 отправляют клавиши курсора вверх и вниз, когда xterm отображает
 альтернативный экран. По умолчанию «false».
 Состояние alterScroll
 также можно установить с помощью управляющей последовательности.
";;
g)load;clear;echo -e "
\e[32m alwaysBoldMode\e[0m (class AlwaysBoldMode)
 Указывает, должен ли xterm проверять, различаются ли обычный и полужирный шрифты,
 прежде чем принимать решение о том, следует ли использовать зачеркивание для
 имитации полужирных шрифтов.
 Если этот ресурс имеет значение true, xterm не выполняет проверку различных
 шрифтов при принятии решения о том, как обращаться с ресурсом boldMode.
 По умолчанию «false».

 boldMode   alwaysBoldMode   Comparison   Action
 ────────────────────────────────────────────────────
 false      false            игнорируется использование шрифта
 false      true             игнорируется использование шрифта
 true       false            тот же       вычеркнуть
 true       false            различный    использование шрифта
 true       true             игнорируется вычеркнуть

 Этот ресурс используется только для растровых шрифтов:
 • При использовании растровых шрифтов сервер шрифтов может аппроксимировать
 полужирный шрифт, изменив его размер из-за размера шрифта, отличного от ожидаемого.
 Ресурс alwaysBoldMode позволяет пользователю переопределить (иногда некачественный)
 полученный полужирный шрифт с зачеркиванием (что, по крайней мере, соответствует).
 • Проблема не возникает со шрифтами TrueType (хотя могут быть другие ненужные
 проблемы, такие как разное покрытие обычного и полужирного шрифтов).
 В качестве альтернативы установка для ресурса allowBoldFonts значения false
 переопределяет как ресурсы alwaysBoldMode, так и ресурсы boldMode.
";;
h)load;clear;echo -e "
\e[32m alwaysHighlight\e[0m (class AlwaysHighlight)
 Указывает, должен ли xterm всегда отображать выделенный текстовый курсор.
 По умолчанию (если этот ресурс имеет значение false) пустой текстовый курсор
 отображается всякий раз, когда указатель перемещается за пределы окна
 или окно теряет фокус ввода. По умолчанию «ложь».
";;
i)load;clear;echo -e "
\e[32m alwaysUseMods\e[0m (class AlwaysUseMods)
 Переопределите ресурс numLock, указав xterm использовать модификаторы Alt и Meta
 для создания параметров последовательностей функциональных клавиш, даже если эти
 модификаторы появляются в ресурсе переводов.
 Обычно xterm проверяет, используется ли Alt или Meta в переводе, который может
 конфликтовать с модификаторами функциональных клавиш,
 и игнорирует эти модификаторы в этом особом случае. По умолчанию «false».
";;
j)load;clear;echo -e "
\e[32m answerbackString\e[0m (class AnswerbackString)
 Указывает строку, которую xterm отправляет в ответ на символ ENQ (control/E)
 от хоста. По умолчанию используется пустая строка, т. е. «».
 Аппаратный VT100 реализует эту функцию как параметр настройки.
";;
k)load;clear;echo -e "
\e[32m appcursorDefault\e[0m (class AppcursorDefault)
 Если «true», клавиши управления курсором изначально находятся в режиме приложения.
 Это то же самое, что и частный режим DECCKM VT102.
 По умолчанию установлено значение «false».
";;
l)load;clear;echo -e "
\e[32m appkeypadDefault\e[0m (class AppkeypadDefault) Если «true»,
 клавиши клавиатуры изначально находятся в режиме приложения. По умолчанию «false»
";;
m)load;clear;echo -e "
\e[32m assumeAllChars\e[0m (class AssumeAllChars)
 Если установлено значение «true», это включает особый случай растровых шрифтов,
 позволяющий серверу шрифтов выбирать, как отображать отсутствующие глифы.
 По умолчанию установлено значение «истина».
 Этот ресурс предназначен для помощи с некоторыми квазиавтоматически
 сгенерированными шрифтами (такими как кодировка ISO-10646-1 Terminus),
 которые имеют неверные метрики шрифта.
";;
n)load;clear;./nXtermResourcesVT100WidgetB.sh;;
*)
clear
echo -e "\e[33m Неверный ввод данных, пожалуйста повторите ввод \e[0m";;
esac
echo -en "\e[33m Пожалуйста нажмите любую клавишу для продолжения \e[0m"
read -n 1 line
done
clear
