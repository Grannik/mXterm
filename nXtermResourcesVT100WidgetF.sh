#!/bin/bash
 a="\e[1;32m+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\e[0m"
 b="\e[1;32m+--------------------------------------------------------------------------------+\e[0m"
#c
#d
#e
function menu {
clear
tput cup 0 0; echo -e "$a"
tput cup 1 0
 for (( c=0; c<=36; c++ ))
  do
   echo -e "\e[1;32m|                                                                                |\e[0m"
  done
#
tput cup  1  1;echo -e "\e[1;36m VT100 Widget Resources \e[0m\e[36m Ресурсы виджетов VT100\e[0m                           - F -"
tput cup  2  0;echo -e "$b"
tput cup  3  1;echo -e "\e[33m [1]\e[0m Указывает, следует ли звонить в колокольчик                    \e[32m marginBell\e[0m"
tput cup  4  1;echo -e "\e[33m [2]\e[0m Если xterm настроен на поддержку графики ReGIS или SIXEL   \e[32m maxGraphicSize\e[0m"
tput cup  5  1;echo -e "\e[33m [3]\e[0m Сообщает xterm, что делать с символами, измененными Meta  \e[32m metaSendsEscape\e[0m"
tput cup  6  1;echo -e "\e[33m [4]\e[0m mkSampleSize не равен нулю, mkWidth (и cjkWidth) равны  false\e[32m mkSamplePass\e[0m"
tput cup  7  1;echo -e "\e[33m [5]\e[0m mkSamplePass это указывает тест запуска                      \e[32m mkSampleSize\e[0m"
tput cup  8  1;echo -e "\e[33m [6]\e[0m должен ли xterm использовать встроенную версию расчета ширины     \e[32m mkWidth\e[0m"
tput cup  9  1;echo -e "\e[33m [7]\e[0m Рассказывает, как обрабатывать особый случай             \e[32m modifyCursorKeys\e[0m"
tput cup 10  1;echo -e "\e[33m [8]\e[0m Рассказывает, как обрабатывать особый случай           \e[32m modifyFunctionKeys\e[0m"
tput cup 11  1;echo -e "\e[33m [9]\e[0m xterm делает особый случай в отношении модификаторов       \e[32m modifyKeyboard\e[0m"
tput cup 12  1;echo -e "\e[33m [a]\e[0m сообщает xterm создать управляющую последовательность     \e[32m modifyOtherKeys\e[0m"
tput cup 13  1;echo -e "\e[33m [b]\e[0m максимальное время в миллисекундах между событиями выбора  \e[32m multiClickTime\e[0m"
tput cup 14  1;echo -e "\e[33m [c]\e[0m Указывает, должна ли прокрутка выполняться асинхронно         \e[32m multiScroll\e[0m"
tput cup 15  1;echo -e "\e[33m [d]\e[0m Указывает количество символов от правого поля                 \e[32m nMarginBell\e[0m"
tput cup 16  1;echo -e "\e[33m [e]\e[0m См. обсуждение действия keymap                                 \e[32m nameKeymap\e[0m"
tput cup 17  1;echo -e "\e[33m [f]\e[0m Указывает время задержки перед проверкой новых событий X   \e[32m nextEventDelay\e[0m"
tput cup 18  1;echo -e "\e[33m [g]\e[0m указывает количество доступных цветовых регистров       \e[32m numColorRegisters\e[0m"
tput cup 19  1;echo -e "\e[33m [h]\e[0m escape-последовательности старого стиля (X11R5)             \e[32m oldXtermFKeys\e[0m"
tput cup 20  1;echo -e "\e[33m [i]\e[0m                                                                 \e[32m on2Clicks\e[0m"
tput cup 21  1;echo -e "\e[33m [j]\e[0m                                                                 \e[32m on3Clicks\e[0m"
tput cup 22  1;echo -e "\e[33m [k]\e[0m                                                                 \e[32m on4Clicks\e[0m"
tput cup 23  1;echo -e "\e[33m [l]\e[0m Укажите поведение выбора в ответ на несколько щелчков мышью     \e[32m on5Clicks\e[0m"
tput cup 24  1;echo -e "\e[33m [m]\e[0m следует ли открывать метод ввода при запуске                       \e[32m openIm\e[0m"
tput cup 25  1;echo -e "\e[33m [n]\e[0m Определяет цвет переднего плана указателя                    \e[32m pointerColor\e[0m"
tput cup 26  1;echo -e "\e[33m [o]\e[0m Определяет цвет фона указателя                     \e[32m pointerColorBackground\e[0m"
tput cup 27  1;echo -e "\e[33m [p]\e[0m Указывает шрифт, который будет использоваться для указателя   \e[32m pointerFont\e[0m"
tput cup 28  1;echo -e "\e[33m [q]\e[0m когда указатель может быть скрыт при вводе пользователем      \e[32m pointerMode\e[0m"
tput cup 29  1;echo -e "\e[33m [r]\e[0m Указывает имя формы указателя                                \e[32m pointerShape\e[0m"
tput cup 30  1;echo -e "\e[33m [s]\e[0m Указывает, будет ли открываться окно при получении Control-G    \e[32m popOnBell\e[0m"
tput cup 31  1;echo -e "\e[33m [t]\e[0m следует ли предварительно компоновать данные UTF-8             \e[32m precompose\e[0m"
tput cup 32  1;echo -e "\e[33m [u]\e[0m какие типы строки предварительного редактирования отображать  \e[32m preeditType\e[0m"
tput cup 33  0;echo -e "$b"
#
tput cup 35  0;echo -e "$b"
tput cup 36  1;echo -e "\e[33m [v]\e[0m Далее                                                                \e[32m Next\e[0m"
tput cup 37  1;echo -e "\e[33m [0]\e[0m Выход                                                                \e[32m Exit\e[0m"
tput cup 38  0;echo -e "$a"
#
tput cup 34  1;echo -e "\e[33m [ ]\e[0m Ожидание ввода команды: "
tput cup 34 30;read -n 1 option
#
}
#menu software
while [ $? -ne 1 ]
do
menu
case $option in
0)
clear
exit 0
;;
1)load;clear;echo -e "
\e[32m marginBell\e[0m (class MarginBell)
 Указывает, следует ли звонить в колокольчик,
 когда пользователь печатает рядом с правым полем. The default is “false”.
";;
2)load;clear;echo -e "
\e[32m maxGraphicSize\e[0m (class MaxGraphicSize)
 Если xterm настроен на поддержку графики ReGIS или SIXEL,
 этот ресурс определяет максимальный размер отображаемого графика.
 Значение по умолчанию — «1000x1000» (задается как ширина по высоте).
 Если ресурс «auto», тогда xterm будет использовать ресурс decGraphicsID
 (или decTerminalID, если он не установлен):
\e[32m
 Result    decGraphicsID
 ────────────────────────
 768x400             125
 800x460             240
 800x460             241
 800x480             330
 800x480             340
 860x750             382
 800x480           other
\e[0m
";;
3)load;clear;echo -e "
\e[32m metaSendsEscape\e[0m (class MetaSendsEscape)
 Сообщает xterm, что делать с входными символами, измененными Meta:
 • Если установлено значение «true», метасимволы (символ в сочетании
 с клавишей-модификатором Meta) преобразуются в двухсимвольную последовательность,
 в которой самому символу предшествует клавиша ESC.
 Это также относится к последовательностям управления функциональными клавишами,
 если только xterm не увидит, что Meta используется в ваших переводах клавиш.
 • Если установлено значение «false», метасимволы, вводимые с клавиатуры,
 обрабатываются в соответствии с ресурсом sixBitInput.
 The default is “False”.
";;
4)load;clear;echo -e "
\e[32m mkSamplePass\e[0m (class MkSamplePass)
 Если mkSampleSize не равен нулю, а mkWidth (и cjkWidth) равны false, при запуске
 xterm сравнивает свои встроенные таблицы с данными ширины широких символов системы,
 чтобы решить, будет ли он использовать системные данные.
 Он проверяет первые значения символов mkSampleSize и допускает до несоответствия
 mkSamplePass до того, как тест завершится ошибкой.
 Значение по умолчанию (для допустимого количества несоответствий) равно 655
 (один процент от значения по умолчанию для mkSampleSize).
";;
5)load;clear;echo -e "
\e[32m mkSampleSize\e[0m (class MkSampleSize)
 В случае с mkSamplePass это указывает тест запуска, используемый для инициализации
 вычислений ширины широких символов.
 По умолчанию (количество проверяемых символов) — 65536.
";;
6)load;clear;echo -e "
\e[32m mkWidth\e[0m (class MkWidth)
 Указывает, должен ли xterm использовать встроенную версию расчета ширины широкого
 символа. См. также ресурс cjkWidth, который может переопределить это.
 По умолчанию «ложь».
 Вот сводка ресурсов, которые контролируют выбор расчета ширины широкого символа:
\e[32m
 cjkWidth   mkWidth   Action
 ───────────────────────────────────────────────────────────────
 false      false     использовать системные таблицы с учетом mkSamplePass
 false      true      использовать встроенные таблицы
 true       false     использовать встроенные таблицы CJK
 true       true      использовать встроенные таблицы CJK
\e[0m
 Чтобы отключить mkWidth и использовать системные таблицы, установите для
 mkSampleSize и mkSamplePass значение «0». Это может сделать xterm более
 совместимым с приложениями, работающими в xterm, но может пропустить некоторые
 глифы шрифта, ширина которых правильно отличается от ширины системы таблицы символов.
";;
7)load;clear;echo -e "
\e[32m modifyCursorKeys\e[0m (class ModifyCursorKeys)
 Рассказывает, как обрабатывать особый случай, когда используются
 Control-, Shift-, Alt- или Meta-модификаторы для добавления параметра к
 управляющей последовательности, возвращаемой клавишей курсора. По умолчанию «2»:
 -1 отключает функцию.
 0 использует старое/устаревшее поведение, т. е. модификатор является первым параметром.
 1 префикс измененных последовательностей с CSI.
 2 заставляет модификатор быть вторым параметром, если в противном случае он был бы первым.
 3 помечает последовательность знаком «>», чтобы намекнуть, что она является частной.
";;
8)load;clear;echo -e "
 modifyFunctionKeys\e[0m (class ModifyFunctionKeys)
 Рассказывает, как обрабатывать особый случай, когда используются
 Control-, Shift-, Alt- или Meta-модификаторы для добавления параметра
 к управляющей последовательности, возвращаемой функциональной клавишей 
(с номером). По умолчанию «2». Значения ресурса аналогичны ModifyCursorKeys:
 -1 позволяет пользователю использовать модификаторы shift и control для создания
    строк функциональных клавиш с использованием обычной схемы кодирования.
  0 использует старое/устаревшее поведение,
    т. е. модификатор является первым параметром.
  1 префикс измененных последовательностей с CSI.
  2 заставляет модификатор быть вторым параметром,
    если в противном случае он был бы первым.
  3 помечает последовательность знаком «>»,
    чтобы намекнуть, что она является частной.

 Если modifyFunctionKeys равен нулю, xterm использует Control-
 и Shift-модификаторы, чтобы позволить пользователю создавать пронумерованные
 функциональные клавиши помимо набора, предоставляемого клавиатурой:
 Control       добавляет значение, заданное ресурсом ctrlFKeys.
 Shift         добавляет вдвое значение, заданное ресурсом ctrlFKeys.
 Control/Shift добавляет в три раза значение, заданное ресурсом ctrlFKeys.
";;
9)load;clear;echo -e "
\e[32m modifyKeyboard\e[0m (class ModifyKeyboard)
 Обычно xterm делает особый случай в отношении модификаторов (shift, control и т.д.
 для обработки специальных раскладок клавиатуры (устаревшие и vt220).
 Это сделано для обеспечения совместимых клавиатур для DEC VT220 и связанных с ним
 терминалов, в которых реализованы определяемые пользователем клавиши (UDK).
 Биты значения ресурса выборочно разрешают изменение данной категории при выборе
 этих клавиатур. По умолчанию «0»:
 0 Клавиатуры legacy/vt220 интерпретируют только модификатор Control при создании
   нумерованных функциональных клавиш. Другие специальные ключи не модифицируются.
 1 позволяет модифицировать цифровую клавиатуру
 2 позволяет модифицировать клавиатуру редактирования
 4 позволяет изменять функциональные клавиши,
   отменяет использование модификатора Shift для UDK.
 8 позволяет модифицировать другие специальные клавиши
";;
a)load;clear;echo -e "
\e[32m modifyOtherKeys\e[0m (class ModifyOtherKeys)
 Как и modifyCursorKeys, сообщает xterm создать управляющую последовательность
 для обычных (то есть «других») клавиш (например, «2») при изменении с помощью
 модификаторов Shift, Control, Alt или Meta. Эта функция не применяется к
 специальным клавишам, т. е. клавишам курсора, клавиатуры, функциональным
 клавишам или клавишам управления, которые помечены на вашей клавиатуре.
 У них есть ключевые символы, которые XKB идентифицирует однозначно.
 Например, эта функция не применяется к специальным клавишам управления
 (например, Escape, Tab, Enter, Backspace).
 Другие клавиши управления (например, Control-I, Control-M, Control-H)
 могут отправлять escape-последовательности, когда эта функция включена. включено.
 По умолчанию «0»:
 0 отключает эту функцию.
 1 включает эту функцию для клавиш, за исключением клавиш с хорошо известным
   поведением, например, Tab, Backarrow и некоторых специальных регистров
   управляющих символов, которые встроены в библиотеку X11, например,
   Control-Space, чтобы сделать NUL, или Control-3, чтобы сделать Escape-символ.
   За исключением особых случаев, встроенных в библиотеку X11, модификаторы Shift-
   и Control- обрабатываются нормально. Модификаторы Alt- и Meta- не заставляют
   xterm отправлять управляющие последовательности. Эти ключи-модификаторы
   интерпретируются в соответствии с другими ресурсами, например ресурсом
   metaSendsEscape.
 2 включает эту функцию для ключей, включая перечисленные исключения.
   Xterm игнорирует специальные случаи, встроенные в библиотеку X11.
   Любая смещенная (модифицированная) обычная клавиша отправляет управляющую
   последовательность. Модификаторы Alt- и Meta- заставляют xterm отправлять
   управляющие последовательности.
 В FAQ Xterm есть расширенное обсуждение этой функции с примерами:
 https://invisible-island.net/xterm/modified-keys.html
";;
b)load;clear;echo -e "
\e[32m multiClickTime\e[0m (class MultiClickTime)
 Указывает максимальное время в миллисекундах между событиями выбора с несколькими
 щелчками мыши. Значение по умолчанию — «250» миллисекунд.
";;
c)load;clear;echo -e "
\e[32m multiScroll\e[0m (class MultiScroll)
 Указывает, должна ли прокрутка выполняться асинхронно. The default is “false”.
";;
d)load;clear;echo -e "
\e[32m nMarginBell\e[0m (class Column)
 Указывает количество символов от правого поля, при котором должен звонить
 колокольчик, если он включен ресурсом marginBell. По умолчанию «10».
";;
e)load;clear;echo -e "
\e[32m nameKeymap\e[0m(class NameKeymap)
 См. обсуждение действия keymap().
";;
f)load;clear;echo -e "
\e[32m nextEventDelay\e[0m (class NextEventDelay)
 Указывает время задержки в миллисекундах перед проверкой новых событий X.
 По умолчанию «1».
";;
g)load;clear;echo -e "
\e[32m numColorRegisters\e[0m (class NumColorRegisters)
 Если xterm настроен на поддержку графики ReGIS или SIXEL, это указывает
 количество доступных цветовых регистров. Если этот ресурс не указан,
 xterm использует значение, определяемое ресурсом decTerminalID:
 Result   decTerminalID
 ───────────────────────
    4             125
    4             240
    4             241
    4             330
   16             340
    2             382
 1024           other
"
echo -e "\e[32m numLock\e[0m (class NumLock)
 Если «true», xterm проверяет, используется ли NumLock в качестве модификатора
 (см. xmodmap(1)). Если да, то этот модификатор используется для упрощения логики
 при реализации специального NumLock для ресурса sunKeyboard.
 Также (когда sunKeyboard имеет значение false) аналогичная логика используется
 для поиска модификатора, связанного с левой и правой клавишами Alt.
 The default is “true”.
";;
h)load;clear;echo -e "
\e[32m oldXtermFKeys\e[0m (class OldXtermFKeys)
 Если установлено значение «true», xterm будет использовать
 escape-последовательности старого стиля (X11R5) для функциональных клавиш
 с F1 по F4 для совместимости с X Consortium xterm.
 В противном случае используются коды VT100 для PF1-PF4. По умолчанию «false».
 Установка этого ресурса имеет тот же эффект, что и установка для устаревшего
 типа клавиатуры. Ресурс keyboardType является предпочтительным механизмом
 для выбора этого режима.
 Эскейп-последовательности старого стиля напоминают ключи VT220, но, похоже,
 они были изобретены для xterm в X11R4.
";;
i)load;clear;echo -e "";;
j)load;clear;echo -e "";;
k)load;clear;echo -e "";;
l)load;clear;echo -e "
 Укажите поведение выбора в ответ на несколько щелчков мышью.
 Один щелчок мышью всегда интерпретируется, как описано в разделе «Функции выбора»
 (см. ИСПОЛЬЗОВАНИЕ УКАЗАНИЯ).
 Многократные щелчки мышью (с использованием кнопки, которая активирует действие
 выбора-запуска) интерпретируются в соответствии со значениями ресурса on2Clicks
 и т. д. Значение ресурса может быть одним из следующих:
\e[32m word\e[0m Выберите «слово», определенное ресурсом charClass.
 См. раздел КЛАССЫ ПЕРСОНАЖЕЙ. Если указатель находится на «слове»,
 тогда xterm выполняет поиск в начале слова, а затем в конце.
 Если указатель не находится на «слове», то результат зависит от того, находится
 ли он на пробеле (включая новую строку) или за концом строки. В последнем случае
 xterm может выбрать «слово», начинающееся после новой строки,
 если нет дополнительных пробелов.
\e[32m line\e[0m Выберите линию (с учетом переноса).
\e[32m group\e[0m Выделите группу смежных строк (с учетом переноса).
 Выделение останавливается на пустой строке
 и не выходит за пределы текущей страницы.
\e[32m page\e[0m Выберите все видимые строки, т. е. страницу.
\e[32m all\e[0m Выберите все строки, т.е. включая сохраненные строки.
\e[32m regex\e[0m Выберите наилучшее соответствие расширенному регулярному выражению POSIX (ERE),
 которое следует за значением ресурса:
 • Xterm сопоставляет регулярное выражение с массивом байтов для всей (возможно,
 завернутой) строки. Этот массив байтов может быть UTF-8 или ISO-8859-1,
 в зависимости от режима, в котором работает xterm.
 • Xterm проходит через каждое байтовое смещение в этом массиве, отслеживая
 наилучшее (самое длинное) совпадение. Если более чем одна спичка имеет наибольшую
 длину, используется первая. Xterm делает это, чтобы было удобно щелкнуть в любом
 месте интересующей области и заставить регулярное выражение соответствовать всему
 слову и т. д.
 • Якоря «^» и «\$» в регулярном выражении обозначают концы всей строки.
 • Если регулярное выражение содержит обратную косую черту «\\», их следует
 экранировать «\\\\», потому что библиотеки X интерпретируют обратную косую черту
 в строках ресурсов.
\e[32m none\e[0m С этим ресурсом не связано никакое действие выбора.
 Xterm интерпретирует это как конец списка. Например, вы можете использовать его,
 чтобы отключить тройной (и более высокий) щелчок, установив для on3Clicks
 значение «none».
 Значения по умолчанию для on2Clicks и on3Clicks — «слово» и «строка»
 соответственно. Для on4Clicks или on5Clicks нет значения по умолчанию,
 что делает их неактивными. При запуске xterm определяет максимальное количество
 кликов по установленным значениям ресурса onXClicks.
";;
m)load;clear;echo -e "
\e[32m openIm\e[0m (class OpenIm)
 Сообщает xterm, следует ли открывать метод ввода при запуске. The default is “true”.
";;
n)load;clear;echo -e "
\e[32m pointerColor\e[0m (class PointerColor)
 Определяет цвет переднего плана указателя.
 По умолчанию используется «XtDefaultForeground».
";;
o)load;clear;echo -e "
\e[32m pointerColorBackground\e[0m (class PointerColorBackground)
 Определяет цвет фона указателя. The default is “XtDefaultBackground”.
";;
p)load;clear;echo -e "
\e[32m pointerFont\e[0m (class PointerFont)
 Указывает шрифт, который будет использоваться для указателя.
 Фигуры, заданные pointerShape, являются глифами в этом шрифте.
 Значение ресурса по умолчанию — cursor.
";;
q)load;clear;echo -e "
\e[32m pointerMode\e[0m (class PointerMode)
 Указывает, когда указатель может быть скрыт при вводе пользователем.
 Он будет отображаться повторно,
 если пользователь переместит мышь или щелкнет одну из его кнопок.
 0 никогда
 1 приложение, работающее в xterm, не активировало режим мыши.
   Это значение по умолчанию.
 2 всегда.
";;
r)load;clear;echo -e "
\e[32m pointerShape\e[0m (class Cursor)
 Указывает имя формы указателя. По умолчанию используется «xterm».
 Можно выбрать другие формы. Вот список «основных» (то есть стандартных) имен,
 извлеченных из <X11/cursorfont.h>:
 X_cursor, arrow, based_arrow_down, based_arrow_up, boat, bogosity,
 bottom_left_corner, bottom_right_corner, bottom_side, bottom_tee, box_spiral,
 center_ptr, circle, clock, coffee_mug, cross, cross_reverse, crosshair,
 diamond_cross, dot, dotbox, double_arrow, draft_large, draft_small, draped_box,
 exchange, fleur, gobbler, gumby, hand1, hand2, heart, icon, iron_cross, left_ptr,
 left_side, left_tee, leftbutton, ll_angle, lr_angle, man, middlebutton, mouse,
 pencil, pirate, plus, question_arrow, right_ptr, right_side, right_tee,
 rightbutton, rtl_logo, sailboat, sb_down_arrow, sb_h_double_arrow, sb_left_arrow,
 sb_right_arrow, sb_up_arrow, sb_v_double_arrow, shuttle, sizing, spider,
 spraycan, star, target, tcross, top_left_arrow, top_left_corner, top_right_corner,
 top_side, top_tee, trek, ul_angle, umbrella, ur_angle, watch, xterm
 Если вы используете тему курсора,
 ожидайте, что она предоставит около трети этих имен, добавляя другие.
";;
s)load;clear;echo -e "
\e[32m popOnBell\e[0m (class PopOnBell)
 Указывает, будет ли открываться окно при получении Control-G. По умолчанию «false».
 Если окно иконизировано, это не имеет никакого эффекта. Однако ресурс zIconBeep
 предоставляет вам возможность увидеть, для каких окон с пиктограммами прозвучал
 сигнал колокольчика.
";;
t)load;clear;echo -e "
\e[32m precompose\e[0m (class Precompose)
 Сообщает xterm, следует ли предварительно компоновать данные UTF-8 в форму
 нормализации C, которая объединяет часто используемые диакритические знаки с
 базовыми символами. Если этого не сделать, акценты останутся отдельными символами.
 По умолчанию установлено значение «true».
";;
u)load;clear;echo -e "
\e[32m preeditType\e[0m (class PreeditType)
 Сообщает xterm, какие типы строки предварительного редактирования
 (предварительного преобразования) отображать.
 По умолчанию используется «OverTheSpot,Root».
";;
v)load;clear;./nXtermResourcesVT100WidgetG.sh;;
*)
clear
echo -e "\e[33m Неверный ввод данных, пожалуйста повторите ввод \e[0m";;
esac
echo -en "\e[33m Пожалуйста нажмите любую клавишу для продолжения \e[0m"
read -n 1 line
done
clear
