#!/bin/bash
sleep 0.1;echo "
┌────────────────────────────────────────────────────────────────────────────────┐"
sleep 0.1;echo -e "
\e[1;36m Application Resources \e[0m\e[36m Ресурсы приложений\e[0m
"
sleep 0.1;echo " Ресурсы для конкретных приложений (например, «XTerm.NAME») следуют:
"
sleep 0.1;echo -e "\e[32m backarrowKeyIsErase\e[0m (класс BackarrowKeyIsErase)
 Свяжите ресурсы VTxxx backarrowKey и ptyInitialErase вместе, установив состояние
 DECBKM в соответствии с тем, является ли начальный символ стирания символом
 возврата (8) или символом удаления (127). Значение «false» отключает эту функцию.
 По умолчанию установлено значение «Ложь».
 Вот таблицы, показывающие, как первоначальные настройки для
 • обратная стрелкаKeyIsErase (BKIE),
 • BackarrowKey (BK) и
 • ptyInitialErase (PIE) вместе с
 • stty стирающий символ (^H для возврата, ^? для удаления)

 повлияет на DECBKM. Во-первых, xterm получает начальный символ стирания:
 • внутреннее значение xterm равно ^H
 • xterm запрашивает у операционной системы значение, которое показывает stty.
 • ресурс ttyModes может переопределить стирание
 • если ptyInitialErase равно false, xterm будет искать в базе данных терминала

 Резюмируя это в виде таблицы:
 PIE     stty   termcap   erase
 ───────────────────────────────\e[32m
 false    ^H      ^H       ^H
 false    ^H      ^?       ^?
 false    ^?      ^H       ^H
 false    ^?      ^?       ^?
 true     ^H      ^H       ^H
 true     ^H      ^?       ^H
 true     ^?      ^H       ^?
 true     ^?      ^?       ^?
\e[0m
 Используя этот символ стирания, xterm предоставляет дополнительные возможности:
 • если значение backarrowKeyIsErase равно true,
   xterm использует символ стирания для начального состояния DECBKM.
 • если значение backarrowKeyIsErase равно false,
   xterm устанавливает для DECBKM значение 2 (внутреннее).
   Это связывает вместе backarrowKey и управляющую последовательность для DECBKM.
 • приложения могут отправлять последовательность управления для установки/сброса
   набора управления DECBKM
 • пункт меню «Клавиша обратной стрелки (BS/DEL)» переключает DECBKM

 Подводя итоги инициализации:
 erase   BKIE    BK      DECBKM   result
 ────────────────────────────────────────\e[32m
 ^?     false   false     2        ^H
 ^?     false   true      2        ^?
 ^?     true    false     0        ^?
 ^?     true    true      1        ^?
 ^H     false   false     2        ^H
 ^H     false   true      2        ^?
 ^H     true    false     0        ^H
 ^H     true    true      1        ^H
\e[0m"
sleep 0.1;echo -e "\e[32m buffered\e[0m (class Buffered) Обычно xterm строится с поддержкой двойного буфера.
 Этот ресурс можно использовать для его включения или выключения.
 Установка для ресурса значения «true» включает двойную буферизацию.
 Значение по умолчанию неверно.
"
sleep 0.1;echo -e "\e[32m bufferedFPS\e[0m (class BufferedFPS)
 Когда xterm построен с поддержкой двойного буфера,
 это дает максимальное количество кадров в секунду.
 Значение по умолчанию 40 и ограничено диапазоном от 1 до 100.
"
sleep 0.1;echo -e "\e[32m cursorTheme\e[0m (class CursorTheme)
  Библиотека Xcursor позволяет изменять форму и размер указателя.
 Библиотека X11 использует эту библиотеку для расширения вызовов курсора шрифта
 и глифа, используемых такими приложениями, как xterm, для замены внешних файлов
 на встроенные «основные» курсоры, предоставляемые X.
  Xterm использует ресурс pointerShape для выбора формы курсора X.
 Большинство доступных наборов тем курсоров предоставляют неполный набор основных
 курсоров (при возможном добавлении других курсоров). Из-за этого ограничения
 xterm по умолчанию отключает эту функцию.
  Функция темы курсора может быть полезна, потому что курсоры X не масштабируются,
 а на дисплее с высоким разрешением их трудно найти. Некоторые темы курсоров
 включают курсоры большего размера, чтобы обойти это ограничение:
 • Основные курсоры по умолчанию имеют размер 8x8 пикселей;
 • Некоторые темы курсоров включают курсоры до предела X-сервера 64x64 пикселей.
 При запуске xterm устанавливает переменную среды XCURSOR_THEME для включения или
 отключения функции темы курсора. Значение по умолчанию — «нет». Другие значения
 (в том числе «по умолчанию») передаются в библиотеку Xcursor для выбора темы
 курсора.
"
sleep 0.1;echo -e "\e[32m fullscreen (class Fullscreen)\e[0m
 Указывает, должен ли xterm запрашивать у оконного менеджера полноэкранный режим
 при запуске. Xterm принимает либо ключевое слово (без учета регистра),
 либо число, указанное в скобках:

\e[32m false\e[0m
 Полноэкранный макет изначально не используется, но может быть позже с помощью
 выбора меню или последовательности управления.

\e[32m true\e[0m
 Первоначально используется полноэкранный режим, но позже его можно отключить с
 помощью выбора меню или последовательности управления.

\e[32m always\e[0m
 Изначально используется полноэкранный режим, и его нельзя отключить позже
 с помощью выбора меню или последовательности управления.

\e[32m never\e[0m
 Полноэкранный макет не используется и не может быть включен позже
 с помощью выбора меню или последовательности управления. По умолчанию «ложь».
"
sleep 0.1;echo -e "\e[32m hold\e[0m (class Hold) Если это правда, xterm не будет немедленно уничтожать свое окно после
 завершения команды оболочки. Он будет ждать, пока вы не используете оконный
 менеджер, чтобы уничтожить/убить окно, или если вы используете пункты меню,
 которые отправляют сигнал, например, HUP или KILL. Вы можете прокручивать назад,
 выбирать текст и т. д. для выполнения большинства графических операций.
 Однако изменение размера дисплея приведет к потере данных, поскольку это связано
 с взаимодействием с оболочкой, которая больше не работает.
"
sleep 0.1;echo -e "\e[32m hpFunctionKeys\e[0m (class HpFunctionKeys)
 Указывает, следует ли генерировать escape-коды функциональных клавиш HP для
 функциональных клавиш. По умолчанию установлено значение «false», т. е. эта
 функция отключена.
 Ресурс keyboardType является предпочтительным механизмом для выбора этого режима.
"
sleep 0.1;echo -e "\e[32m iconGeometry\e[0m (class IconGeometry) Указывает предпочтительный размер
 и положение приложения при отображении в виде значка.
 Это не обязательно соблюдается всеми оконными менеджерами.
"
sleep 0.1;echo -e "\e[32m iconHint\e[0m (class IconHint)
 Определяет значок, который будет добавлен к подсказкам оконного менеджера.
 Xterm не предоставляет значения по умолчанию.
 Установите для этого ресурса значение «none», чтобы полностью исключить подсказку,
 используя любое решение оконного менеджера.
 Если указан ресурс iconHint (или задан параметром -n), xterm ищет файл растрового
 изображения с таким именем в текущем каталоге, а также в /usr/share/pixmaps
 если ресурс не указывает абсолютный путь.
 В каждом случае xterm добавляет «_48x48» и/или «.xpm» к имени файла после
 попытки без этих суффиксов.
 Если он может загрузить файл, xterm устанавливает подсказку оконного менеджера
 для icon-pixmap. Эти растровые изображения распространяются вместе с xterm
 и могут быть дополнительно скомпилированы:
 • мини.xterm_16x16, мини.xterm_32x32, мини.xterm_48x48
 • заполнено-xterm_16x16, заполнено-xterm_32x32, заполнено-xterm_48x48
 • xterm_16x16, xterm_32x32, xterm_48x48
 • xterm-color_16x16, xterm-color_32x32, xterm-color_48x48
 В любом случае xterm позволяет добавить «_48x48», чтобы указать самое большое
 из растровых изображений по умолчанию. То есть «mini.xterm» — это то же самое,
 что и «mini.xterm_48x48».
 Если явный ресурс iconHint не указан (или если ни одно из скомпилированных имен
 не совпадает), xterm использует «mini.xterm» (который всегда скомпилирован).
 Ресурс iconHint не влияет на файлы «рабочего стола», включая «панель» и «меню».
 Обычно они устанавливаются через файл «.desktop»;
 xterm предоставляет образцы для себя (и скрипт uxterm). Более мощные настольные
 системы позволяют изменять значок для каждого пользователя.
"
sleep 0.1;echo -e "\e[32m iconName\e[0m (class IconName) Задает метку для xterm при отображении в виде значка.
 Xterm не предоставляет значения по умолчанию; некоторые оконные менеджеры могут
 использовать имя приложения, например, «xterm».
 Установка ресурса iconName задает метку значка, если она не переопределена
 zIconBeep или управляющими последовательностями,
 которые изменяют метки окна и значка.
"
sleep 0.1;echo -e "\e[32m keyboardType\e[0m (class KeyboardType)
 Включает один (или ни один) из различных ресурсов типа клавиатуры:
 hpFunctionKeys,
 scoFunctionKeys,
 sunFunctionKeys,
 tcapFunctionKeys,
 oldXtermFKeys
 sunKeyboard.
 Значение ресурса должно быть одной из соответствующих строк:
 «hp», «sco», «sun», «tcap», «legacy» или «vt220» соответственно.
 Отдельные ресурсы предоставляются для устаревшей поддержки;
 этот ресурс проще в использовании.
 Xterm будет использовать только один тип клавиатуры, но если установлено
 несколько ресурсов, он предупреждает и использует последний проверенный тип.
 Значение по умолчанию — «неизвестно»,
 т. е. через этот ресурс не устанавливается ни один из связанных ресурсов.
"
sleep 0.1;echo -e "\e[32m maxBufSize\e[0m (class MaxBufSize)
 Укажите максимальный размер входного буфера. По умолчанию «32768».
 Вы не можете установить для него значение меньше, чем ресурс minBufSize.
 Оно будет увеличиваться по мере необходимости, чтобы это значение равномерно
 делилось на это.
 В некоторых системах может потребоваться увеличить одно или оба значения ресурсов
 maxBufSize и minBufSize для повышения производительности,
 если операционная система предпочитает буферы большего размера.
"
sleep 0.1;echo -e "\e[32m maximized\e[0m (class Maximized)
 Указывает, должен ли xterm запрашивать у оконного менеджера максимизацию макета
 при запуске. По умолчанию «ложь».
"
sleep 0.1;echo -e "\e[32m menuHeight\e[0m (class MenuHeight)
 Определяет высоту панели инструментов, которая может быть увеличена виджетом
 компоновки X toolkit в зависимости от используемого размера шрифта.
 По умолчанию «25».
"
sleep 0.1;echo -e "\e[32m menuLocale\e[0m (class MenuLocale)
 Укажите локаль, используемую для вычислений набора символов, при загрузке
 всплывающих меню. Используйте это, чтобы улучшить производительность
 инициализации всплывающих меню Athena, которые могут загружать ненужные (и очень
 большие) шрифты, например, в локали с кодировкой UTF-8.
 По умолчанию используется «C» (POSIX).
 Чтобы использовать текущую локаль (полезно только в том случае, если вы
 локализовали настройки ресурса для пунктов меню),
 установите для ресурса пустую строку.
"
sleep 0.1;echo -e "\e[32m messages\e[0m (class Messages)
 Указывает, разрешен ли изначально доступ для записи к терминалу.
 См. сообщение (1). По умолчанию установлено значение «истина».
"
sleep 0.1;echo -e "\e[32m minBufSize\e[0m (class MinBufSize)
 Укажите минимальный размер входного буфера, т. е. объем данных, которые xterm
 запрашивает при каждом чтении. По умолчанию «4096».
 Вы не можете установить значение меньше 64.
"
sleep 0.1;echo -e "\e[32m omitTranslation\e[0m (class OmitTranslation)
 Выборочно опустить одну или несколько частей перевода xterm по умолчанию при
 запуске. Значение ресурса представляет собой список ключевых слов,
 разделенных запятыми, который может быть сокращен:
\e[32m default\e[0m дефолт
 игнорировать (мышь) события нажатия кнопки,
 которые не обрабатывались другими переводами

\e[32m fullscreen\e[0m fullscreen
 присваивает привязку клавиш действию fullscreen().

\e[32m keypress\e[0m нажатие клавиши
 по умолчанию назначает нажатия клавиш действиям вставки-семибита()
 и вставки-восьмибита().

\e[32m paging\e[0m
 назначает привязки клавиш для действий scroll-back() и scroll-forw().

\e[32m pointer\e[0m указатель
 назначает события движения указателя и кнопки действиям pointer-motion()
 и pointer-button() соответственно.

\e[32m popup-menu\e[0m всплывающее меню
 назначает кнопки мыши с модификатором управления всплывающим меню.
\e[32m reset\e[0m
 назначает кнопку мыши 2 с модификатором мета
 для действия очистки сохраненных строк.

\e[32m scroll-lock\e[0m прокрутка-замок
 назначает привязку клавиш действию scroll-lock().

\e[32m select\e[0m
 назначает комбинации клавиш и мыши действиям, управляющим выделением.

 Xterm также использует эти действия для захвата кнопок мыши
 и событий движения, которыми можно манипулировать с помощью управляющих
 последовательностей протокола мыши. Если выбранные переводы опущены,
 то вместо этого управляющие последовательности протокола мыши
 обрабатываются указателем-движением и указателем-кнопкой.

\e[32m shift-fonts\e[0m Shift-шрифты
 назначает привязки клавиш действиям large-vt-font() и small-vt-font().

\e[32m wheel-mouse\e[0m колесико мыши
 назначает кнопки 4 и 5 с разными модификаторами
 для действий scroll-back() и scroll-forw().
"
sleep 0.1;echo -e "\e[32m ptyHandshake\e[0m (class PtyHandshake) Если установлено значение «true»,
 xterm выполнит квитирование во время инициализации, чтобы убедиться, что роди-
 тельский и дочерний процессы обновляют состояние utmp и stty.
 См. также waitForMap, который ожидает представления псевдотерминала о размере
 экрана, и ptySttySize, который сбрасывает размер экрана после завершения иници-
ализации другого терминала. Значение по умолчанию — «true».
"
sleep 0.1;echo -e "\e[32m ptyInitialErase\e[0m (class PtyInitialErase) Если установлено значение «true»,
 xterm будет использовать псевдотерминальный смысл значения стирания stty.
 Если «false», xterm установит значение стирания stty в соответствии со своей соб-
 ственной конфигурацией, используя строку kb из записи termcap в качестве ссылки,
 если доступно. В любом случае результат применяется к переменной TERMCAP,
 которую устанавливает xterm, если система использует TERMCAP.
 См. также ресурс ttyModes, который может переопределить это.
 По умолчанию установлено значение «Ложь».
"
sleep 0.1;echo -e "\e[32m ptySttySize\e[0m (class PtySttySize) Если «true»,
 xterm сбросит размер экрана после завершения инициализации терминала.
 Это необходимо для некоторых систем, псевдотерминалы которых не могут передавать
 терминальные характеристики. Там, где он не нужен, он может мешать другим методам
 установки начального размера экрана, например, через взаимодействие с оконным
 менеджером. См. также waitForMap, который ожидает сообщения о рукопожатии,
 дающего псевдотерминалу представление о размере экрана.
 По умолчанию используется значение «false» в системах Linux и macOS,
 «true» в противном случае.
"
sleep 0.1;echo -e "\e[32m reportColors\e[0m (class ReportColors) Если true,
 xterm выведет на стандартный вывод сводку цветов по мере их распределения.
 По умолчанию «false».
"
sleep 0.1;echo -e "\e[32m reportFonts\e[0m (class ReportFonts)
 Если true, xterm выведет на стандартный вывод сводку показателей каждого шрифта
 (размер, количество глифов и т. д.) по мере их загрузки.
 Значение по умолчанию — «false».
"
sleep 0.1;echo -e "\e[32m reportIcons\e[0m (class ReportIcons) Если true,
 xterm выведет на стандартный вывод сводку по каждому значку растрового
 изображения по мере их загрузки. По умолчанию «ложь».
"
sleep 0.1;echo -e "\e[32m reportXRes\e[0m (class ReportXRes) Если true,
 xterm выведет на стандартный вывод список логических, числовых и строковых
 ресурсов X для виджета VT100 после инициализации. По умолчанию «ложь».
"
sleep 0.1;echo -e "\e[32m sameName\e[0m (class SameName)
 Если значение этого ресурса равно «true»,
 xterm не отправляет запросы на изменение имени заголовка и значка, когда запрос
 не имеет никакого эффекта: имя не изменяется. Преимущество этого заключается в
 предотвращении мерцания, а недостаток в том, что требуется дополнительное
 обращение к серверу, чтобы узнать предыдущее значение. На практике это никогда
 не должно быть проблемой. По умолчанию установлено значение «истина».
"
sleep 0.1;echo -e "\e[32m scaleHeight\e[0m (class ScaleHeight)
 Масштабируйте значения высоты строки по значению ресурса, которое ограничено от
 «0,9» до «1,5». Значение по умолчанию — «1,0»,
 Хотя этот ресурс применим как к растровым шрифтам, так и к шрифтам TrueType,
 его основная цель — помочь обойти несовместимые изменения в метриках шрифтов
 библиотеки Xft. ). Однако некоторые функции Xft (например, автохинтер) могут
 привести к тому, что глифы будут масштабироваться больше, чем ограничивающие
 рамки, и частично перезаписываться следующей строкой.
 См. useClipping для связанного ресурса.
"
sleep 0.1;echo -e "\e[32m scoFunctionKeys\e[0m (class ScoFunctionKeys)
 Указывает, следует ли генерировать управляющие коды функциональных клавиш SCO
 для функциональных клавиш. По умолчанию установлено значение «false», т. е. эта
 функция отключена.
 Ресурс keyboardType является предпочтительным механизмом для выбора этого режима.
"
sleep 0.1;echo -e "\e[32m sessionMgt\e[0m (class SessionMgt)
 Если значение этого ресурса равно true, xterm устанавливает обратные вызовы
 диспетчера сеансов для XtNdieCallback и XtNsaveCallback.
 По умолчанию установлено значение «true».
"
sleep 0.1;echo -e "\e[32m sunFunctionKeys\e[0m (class SunFunctionKeys)
 Указывает, следует ли генерировать escape-коды функциональных клавиш Sun для
 функциональных клавиш. По умолчанию установлено значение «false», т. е. эта
 функция отключена.
 Ресурс keyboardType является предпочтительным механизмом для выбора этого режима.
"
sleep 0.1;echo -e "\e[32m sunKeyboard\e[0m (class SunKeyboard)
 Xterm переводит определенные ключевые символы на основе своих предположений о
 вашей клавиатуре. Этот ресурс указывает, следует ли использовать раскладку
 клавиатуры Sun/PC (т. е. цифровую клавиатуру вместе с 12 функциональными
 клавишами) вместо DEC VT220. Это приводит к тому, что клавиатура «+»
 сопоставляется с «,». и CTRL от F1-F10 до F11-F20, в зависимости от настройки
 ресурса ctrlFKeys, поэтому xterm более точно эмулирует DEC VT220.
 В противном случае (по умолчанию, когда для sunKeyboard установлено значение
 «false»), xterm использует привязки в стиле ПК для функциональных клавиш и
 клавиатуры. Привязки в стиле ПК используют клавиши Shift, Alt, Control и Meta
 в качестве модификаторов функциональных клавиш и клавиатуры (подробности см. в
 разделе Последовательности управления Xterm). Привязки в стиле ПК аналогичны
 PCTerm, но это не одно и то же. Обычно эти привязки не конфликтуют с
 использованием мета-ключа, как описано для ресурса восемьбитинпут.
 Если они это сделают, обратите внимание, что привязки в стиле ПК оцениваются
 в первую очередь. См. также ресурс keyboardType.
"
sleep 0.1;echo -e "\e[32m tcapFunctionKeys\e[0m (class TcapFunctionKeys)
 Указывает, следует ли генерировать escape-коды функциональных клавиш, считанные
 из записи termcap/terminfo, соответствующей переменной среды TERM, для
 функциональных клавиш вместо настроенных с помощью sunKeyboard и keyboardType.
 По умолчанию установлено значение «false», т. е. эта функция отключена.
 Ресурс keyboardType является предпочтительным механизмом для выбора этого режима.
"
sleep 0.1;echo -e "\e[32m termName\e[0m (class TermName)
 Задает имя типа терминала, которое будет установлено в переменной среды TERM.
"
sleep 0.1;echo -e "\e[32m title\e[0m (class Title) Указывает строку,
 которая может использоваться оконным менеджером при отображении этого приложения.
"
sleep 0.1;echo -e "\e[32m toolBar\e[0m (class ToolBar) Указывает, должна ли отображаться панель инструментов.
 По умолчанию установлено значение «истина».
"
sleep 0.1;echo -e "\e[32m ttyModes\e[0m (class TtyModes)
 Задает строку, содержащую ключевые слова для настройки терминала.
 Если не указано иное, они могут быть привязаны к символам.
 Другие ключевые слова задают режимы.
 Не все ключевые слова поддерживаются в данной системе.
 Допустимые ключевые слова включают:
 Keyword   POSIX?   Notes
 ───────────────────────────────────────────────────────────────────────────────
 brk    no  CHAR также может посылать сигнал «прерывания» как окончание строки ввода.
 dsusp  no  CHAR отправит терминальному сигналу «стоп» после сброса ввода.
 eof    yes CHAR завершит ввод (т. е. конец файл).
 eol    yes CHAR завершит строку.
 eol2   no       альтернативного CHAR для окончания строки.
 Erase  yes CHAR удалит последний введенный символ.
 erase2 no      альтернативного CHAR для стирания последнего вводаперсонаж.
 flush  no  CHAR приведет к отбрасыванию вывода до тех пор,
                 пока набирается еще один флеш-символ.
 intr   yes CHAR отправит сигнал «прерывания».
 kill   yes CHAR удалит текущую строку.
 lnext  no  CHAR не будет вводить следующий символ в кавычках.
 quit   yes CHAR отправит сигнал «quit».
 rpnt   no  CHAR перерисовывает текущую строку.
 start  yes CHAR перезапустит вывод после остановки
 status no  CHAR приведет к сгенерированному системой статусу строка для печати.
 stop   yes CHAR остановит вывод.
 susp   yes CHAR отправит терминалу сигнал «стоп»
 swtch  no  CHAR переключится на другой уровень оболочки.
 tabs   yes Mode отключает расширение вкладок.
 -tabs  yes Mode включает вкладку-расширение.
 weras  no  CHAR сотрет последнее набранное слово.
 Управляющие символы могут быть указаны как ^char (например, ^c или ^u) и ^?
 может использоваться для обозначения удаления (127).
 Используйте ^- для обозначения undef. Используйте \034 для представления ^\,
 так как буквальная обратная косая черта в ресурсе X экранирует следующий символ.
 Это очень полезно для переопределения настроек терминала по умолчанию без
 необходимости запускать stty каждый раз при запуске xterm.
 Обратите внимание, однако, что программа stty на данном хосте может использовать
 разные ключевые слова; xterms
"
sleep 0.1;echo -e "\e[32m useInsertMode\e[0m (class UseInsertMode)
 Принудительно используйте режим вставки, добавив соответствующие записи в
 переменную среды TERMCAP. Это полезно, если системный терминтерм не работает.
 (Этот ресурс игнорируется в большинстве систем,
 поскольку TERMCAP не используется). По умолчанию «ложь».
"
sleep 0.1;echo -e "\e[32m utmpDisplayId\e[0m (class UtmpDisplayId)
 Указывает, должен ли xterm пытаться записать идентификатор дисплея
 (номер дисплея и номер экрана), а также имя хоста в системный файл журнала utmp.
 По умолчанию установлено значение «истина».
"
sleep 0.1;echo -e "\e[32m utmpInhibit\e[0m (class UtmpInhibit)
 Определяет, должен ли xterm пытаться записывать терминал пользователя в системный
 файл журнала utmp.
 Если true, xterm не будет пытаться. Значение по умолчанию — «false».
"
sleep 0.1;echo -e "\e[32m validShells\e[0m (class ValidShells)
 Дополнить (добавить) системные файлы /etc/shells, определяя, следует ли
 устанавливать переменную среды «SHELL» при запуске данной программы.
 Значение ресурса представляет собой список строк (разделенных символами новой
 строки). Каждая строка содержит один путь. Xterm игнорирует любую строку,
 начинающуюся с «#», после обрезки начальных/конечных пробелов в каждой строке.
"
sleep 0.1;echo -e "\e[32m waitForMap\e[0m (class WaitForMap)
 Определяет, должен ли xterm ждать начальной карты окна перед запуском подпроцесса.
 Это часть логики ptyHandshake. Когда xterm направляется на ожидание таким образом,
 он передает размер терминала со стороны дисплея псевдотерминала на соединение
 ввода-вывода терминала, например, используя размер в соответствии с оконным
 менеджером. В противном случае используется размер, указанный в значениях
 ресурсов или параметре командной строки -geometry. По умолчанию «ложь».
"
sleep 0.1;echo -e "\e[32m zIconBeep\e[0m (class ZIconBeep)
 То же, что и аргумент командной строки -ziconbeep.
 Если значение этого ресурса не равно нулю, xterms, которые производят выходные
 данные, будучи иконизированными, вызовут звук XBell с заданной громкостью, и к
 заголовкам их значков будет добавлено «***».
 Большинство оконных менеджеров немедленно обнаружат это изменение, показав вам,
 в каком окне находится вывод. (Аналогичная функция была в x10 xterm.)
 Значение по умолчанию — «false».
"
sleep 0.1;echo -e "\e[32m zIconTitleFormat\e[0m (class ZIconTitleFormat)
 Разрешить настройку строки, используемой в функции zIconBeep.
 Значение по умолчанию — «*** %s». Если значение ресурса содержит «%s»,
 то xterm вставляет заголовок значка в этой точке, а не добавляет строку перед
 заголовком значка. (Используется только первый «%s»)."
sleep 0.1;echo "
└────────────────────────────────────────────────────────────────────────────────┘
"

