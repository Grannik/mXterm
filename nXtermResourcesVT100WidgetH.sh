#!/bin/bash
 a="\e[1;32m+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\e[0m"
 b="\e[1;32m+--------------------------------------------------------------------------------+\e[0m"
#c
#d
#e
function menu {
clear
tput cup 0 0; echo -e "$a"
tput cup 1 0
 for (( c=0; c<=36; c++ ))
  do
   echo -e "\e[1;32m|                                                                                |\e[0m"
  done
#
tput cup  1  1;echo -e "\e[1;36m VT100 Widget Resources \e[0m\e[36m Ресурсы виджетов VT100\e[0m                           - H -"
tput cup  2  0;echo -e "$b"
tput cup  3  1;echo -e "\e[33m [1]\e[0m использовать ли PRIMARY или CLIPBOARD для токенов SELECT\e[32m selectToClipboard\e[0m"
tput cup  4  1;echo -e "\e[33m [2]\e[0m действия для выбора и копирования текста с помощью указателя  \e[32m shiftEscape\e[0m"
tput cup  5  1;echo -e "\e[33m [3]\e[0m следует ли активировать действия более крупный vt-font()       \e[32m shiftFonts\e[0m"
tput cup  6  1;echo -e "\e[33m [4]\e[0m отображать ли текст с атрибутом blink, как полужирный     \e[32m showBlinkAsBold\e[0m"
tput cup  7  1;echo -e "\e[33m [5]\e[0m следует ли отображать рамку с указанием мест, где символ\e[32m showMissingGlyphs\e[0m"
tput cup  8  1;echo -e "\e[33m [6]\e[0m Для отладки xterm и приложений                              \e[32m showWrapMarks\e[0m"
tput cup  9  1;echo -e "\e[33m [7]\e[0m следует ли запретить записи в меню основных параметров      \e[32m signalInhibit\e[0m"
tput cup 10  1;echo -e "\e[33m [8]\e[0m следует ли прокручивать одну строку вверх                  \e[32m sixelScrolling\e[0m"
tput cup 11  1;echo -e "\e[33m [9]\e[0m следует ли прокручивать вправо по мере необходимости    \e[32m sixelScrollsRight\e[0m"
tput cup 12  1;echo -e "\e[33m [a]\e[0m Задает предпочтительный размер и положение окна Tektronix     \e[32m tekGeometry\e[0m"
tput cup 13  1;echo -e "\e[33m [b]\e[0m следует ли игнорировать управляющую последовательность         \e[32m tekInhibit\e[0m"
tput cup 14  1;echo -e "\e[33m [c]\e[0m должно ли окно режима Tektronix начинаться с наименьшим размером \e[32m tekSmall\e[0m"
tput cup 15  1;echo -e "\e[33m [d]\e[0m должен ли xterm запускаться в режиме Tektronix                 \e[32m tekStartup\e[0m"
tput cup 16  1;echo -e "\e[33m [e]\e[0m должен ли xterm прокручивать новую страницу                  \e[32m tiXtraScroll\e[0m"
tput cup 17  1;echo -e "\e[33m [f]\e[0m должен ли xterm удалять записи termcap ti и te                \e[32m titeInhibit\e[0m"
tput cup 18  1;echo -e "\e[33m [g]\e[0m принимать ли или возвращать метки окон и значков               \e[32m titleModes\e[0m"
tput cup 19  1;echo -e "\e[33m [h]\e[0m Задает привязки клавиш и кнопок для меню                     \e[32m translations\e[0m"
tput cup 20  1;echo -e "\e[33m [i]\e[0m увидеть выделенный текст, включая все пробелы в конце       \e[32m trimSelection\e[0m"
tput cup 21  1;echo -e "\e[33m [j]\e[0m должен ли быть подчеркнут текст с атрибутом underline           \e[32m underLine\e[0m"
tput cup 22  1;echo -e "\e[33m [k]\e[0m следует ли применять отсечение                          \e[32m useBorderClipping\e[0m"
tput cup 23  1;echo -e "\e[33m [l]\e[0m следует ли использовать отсечение                             \e[32m useClipping\e[0m"
tput cup 24  1;echo -e "\e[33m [m]\e[0m Это указывает, будет ли xterm работать в режиме UTF-8                \e[32m utf8\e[0m"
tput cup 25  1;echo -e "\e[33m [n]\e[0m будет ли xterm использовать шрифты UTF-8                        \e[32m utf8Fonts\e[0m"
tput cup 26  1;echo -e "\e[33m [o]\e[0m комбинировать обычный шрифт ISO-8859-1 со шрифтом ISO-10646-1  \e[32m utf8Latin1\e[0m"
tput cup 27  1;echo -e "\e[33m [p]\e[0m Переопределите целевой список выбора xterm по умолчанию   \e[32m utf8SelectTypes\e[0m"
tput cup 28  1;echo -e "\e[33m [q]\e[0m Приложения могут установить заголовок xterm                     \e[32m utf8Title\e[0m"
tput cup 29  1;echo -e "\e[33m [r]\e[0m Предоставьте альтернативную схему обработки ошибок            \e[32m utf8Weblike\e[0m"
tput cup 30  1;echo -e "\e[33m [s]\e[0m следует ли комбинировать атрибуты видео с цветами          \e[32m veryBoldColors\e[0m"
tput cup 31  1;echo -e "\e[33m [t]\e[0m следует ли использовать видимый звонок (т. е. мигающий)        \e[32m visualBell\e[0m"
tput cup 32  1;echo -e "\e[33m [u]\e[0m Количество миллисекунд задержки визуального звонка        \e[32m visualBellDelay\e[0m"
tput cup 33  0;echo -e "$b"
#
tput cup 35  0;echo -e "$b"
tput cup 36  1;echo -e "\e[33m [v]\e[0m Далее                                                                \e[32m Next\e[0m"
tput cup 37  1;echo -e "\e[33m [0]\e[0m Выход                                                                \e[32m Exit\e[0m"
tput cup 38  0;echo -e "$a"
#
tput cup 34  1;echo -e "\e[33m [ ]\e[0m Ожидание ввода команды: "
tput cup 34 30;read -n 1 option
#
}
#menu software
while [ $? -ne 1 ]
do
menu
case $option in
0)
clear
exit 0
;;
1)load;clear;echo -e "
\e[32m selectToClipboard\e[0m (class SelectToClipboard)
 Сообщает xterm, следует ли использовать PRIMARY или CLIPBOARD для токенов SELECT
 в механизме выбора. Действие set-select может изменить это во время выполнения,
 позволяя пользователю работать с программами, которые обрабатывают только один из
 этих механизмов.
 По умолчанию установлено значение «false», что указывает на использование PRIMARY.
";;
2)load;clear;echo -e "
\e[32m shiftEscape\e[0m (class ShiftEscape)
 Xterm использует ресурс translations, чтобы определить, как вызывать действия
 для выбора и копирования текста с помощью указателя (например, мыши).
 Он также предоставляет протокол мыши, который может использоваться приложениями,
 работающими в xterm, для обнаружения щелчков кнопок мыши.
 Протокол мыши заставляет xterm отправлять специальные escape-последовательности,
 которые позволяют приложению определить, использовались ли модификаторы (например,
 один или несколько из shift, control, alt и meta).
 Xterm предоставляет этот протокол мыши, интерпретируя события кнопок и движений
 в функциях, которые ресурс переводов вызывает для выбора и копирования текста:
 insert-selection\e[32m
 select-end
 select-extend
 select-start
 start-extend
\e[0m
 Пока протокол мыши активен, xterm резервирует большую часть событий кнопок мыши
 для отправки приложению специальных escape-последовательностей.
 Xterm обычно позволяет вам использовать клавишу Shift, чтобы временно отменить
 этот протокол мыши, позволяя использовать действия выбора и копирования.
 Параметр ресурса shiftEscape позволяет указать xterm, следует ли использовать
 клавишу Shift таким образом (т. е. переопределять протокол мыши).
 Xterm принимает либо ключевое слово (без учета регистра),
 либо число, указанное в скобках:
\e[32m false\e[0m Протокол мыши не отправляет специальные escape-последовательности
 при использовании клавиши Shift.
\e[32m true\e[0m Протокол мыши может отправлять специальные escape-последовательности
 при использовании клавиши Shift.
 При запуске xterm анализирует переводы, чтобы увидеть, какие кнопки используются
 в привязках, связанных с кнопками (мыши), для выбора и копирования текста.
 Если клавиша Shift не указана явно в привязке кнопки, xterm позволяет этой кнопке
 с клавишей Shift переопределить протокол мыши.
\e[32m always\e[0m Протокол мыши всегда может отправлять специальные escape-последовательности
 при использовании клавиши Shift.
\e[32m never\e[0m Протокол мыши никогда не будет отправлять специальные escape-последовательности
 при использовании клавиши Shift.
 Xterm интерпретирует последовательность управления, которая может изменить
 этот параметр между «истинным» и «ложным».The default is “false”.
";;
3)load;clear;echo -e "
\e[32m shiftFonts\e[0m (class ShiftFonts)
 Указывает, следует ли активировать действия более крупный vt-font()
 и более мелкий vt-font(),
 которые обычно связаны со сдвинутыми KP_Add и KP_Subtract.
 The default is “true”.
";;
4)load;clear;echo -e "
\e[32m showBlinkAsBold\e[0m (class ShowBlinkAsBold)
 Сообщает xterm, отображать ли текст с атрибутом blink так же, как полужирный.
 Если xterm не настроен для поддержки мигающего текста, по умолчанию используется
 значение «true», что соответствует более старым версиям xterm,
 в противном случае по умолчанию используется значение «false».
";;
5)load;clear;echo -e "
\e[32m showMissingGlyphs\e[0m (class ShowMissingGlyphs)
 Сообщает xterm, следует ли отображать рамку с указанием мест, где использовался
 символ, не представленный шрифтом. The default is “false”.
";;
6)load;clear;echo -e "
\e[32m showWrapMarks\e[0m (class ShowWrapMarks)
 Для отладки xterm и приложений, которые могут манипулировать флагом перенесенной
 строки, записывая текст на правом поле, покажите метку на правой внутренней
 границе окна. Метка показывает, какие строки имеют установленный флаг.
";;
7)load;clear;echo -e "
\e[32m signalInhibit\e[0m (class SignalInhibit)
 Указывает, следует ли запретить записи в меню основных параметров для отправки
 сигналов в xterm. The default is “false”.
";;
8)load;clear;echo -e "
\e[32m sixelScrolling\e[0m (class SixelScrolling)
 Если xterm настроен на поддержку графики SIXEL, этот ресурс сообщает ему,
 следует ли прокручивать одну строку вверх в то время, когда шестёрки должны быть
 записаны после нижней строки в окне.
 По умолчанию установлено значение «false», которое включает прокрутку.
";;
9)load;clear;echo -e "
\e[32m sixelScrollsRight\e[0m (class SixelScrollsRight)
 Если xterm настроен на поддержку графики SIXEL, этот ресурс сообщает ему,
 следует ли прокручивать вправо по мере необходимости, чтобы сохранить текущую
 позицию видимой, а не обрезать график справа.
 По умолчанию установлено значение «false», которое отключает прокрутку.
";;
a)load;clear;echo -e "
\e[32m tekGeometry\e[0m (class Geometry)
 Задает предпочтительный размер и положение окна Tektronix.
 Для этого ресурса нет значений по умолчанию.
";;
b)load;clear;echo -e "
\e[32m tekInhibit\e[0m (class TekInhibit)
 Указывает, следует ли игнорировать управляющую последовательность
 для входа в режим Tektronix. The default is “false”.
";;
c)load;clear;echo -e "
\e[32m tekSmall\e[0m (class TekSmall)
 Указывает, должно ли окно режима Tektronix начинаться с наименьшим размером,
 если не задана явная геометрия. Это полезно при запуске xterm на дисплеях
 с маленькими экранами. The default is “false”.
";;
d)load;clear;echo -e "
\e[32m tekStartup\e[0m (class TekStartup)
 Указывает, должен ли xterm запускаться в режиме Tektronix. The default is “false”
";;
e)load;clear;echo -e "
\e[32m tiXtraScroll\e[0m (class TiXtraScroll)
 Указывает, должен ли xterm прокручивать новую страницу при обработке строк
 termcap ti или te, т. е. частные режимы 47, 1047 или 1049. изображение
 полноэкранного отображения приложения на полосе прокрутки без стирания текста,
 который будет отображаться до инициализации приложения.
 Xterm принимает либо ключевое слово (без учета регистра),
 либо число, указанное в скобках:
\e[32m false\e[0m в прокрутку ничего не добавляется.
\e[32m true \e[0m текущий экран добавляется в прокрутку.
\e[32m trim \e[0m текущий экран добавляется в прокрутку, но повторяющиеся пустые
 строки обрезаются (сокращаются до одной пустой строки).
 По умолчанию для этого ресурса установлено значение «false».
";;
f)load;clear;echo -e "
\e[32m titeInhibit\e[0m (class TiteInhibit)
 Первоначально указывалось, должен ли xterm удалять записи termcap ti и te
 (используемые для переключения между альтернативными экранами при запуске многих
 экранно-ориентированных программ) из строки TERMCAP.
 TERMCAP сейчас используется редко,
 но xterm поддерживает эту функцию в современных системах:
 • Если установлено, xterm также игнорирует управляющую последовательность
   для переключения на альтернативный экран.
 • Xterm поддерживает terminfo по-другому, поддерживая составные управляющие
 последовательности (также известные как частные режимы) 1047, 1048 и 1049,
 которые имеют тот же эффект, что и исходная управляющая последовательность 47.
";;
g)load;clear;echo -e "
\e[32m titleModes\e[0m (class TitleModes)
 Сообщает xterm, следует ли принимать или возвращать метки окон и значков
 в формате ISO-8859-1 (по умолчанию) или UTF-8.
 Любой из них может быть закодирован в шестнадцатеричном формате:
 • Заголовки UTF-8 требуют специальной обработки, поскольку они могут содержать
 байты, которые могут быть ошибочно приняты за управляющие символы.
 Для исключения такой возможности поддерживается шестнадцатеричное кодирование.
 • В качестве альтернативы вы можете использовать ресурс allowC1Printable,
 который подавляет анализ xterm соответствующих управляющих символов
 (и в результате обрабатывает эти байты как данные).
 По умолчанию для этого ресурса установлено значение «0».
 Каждый бит (бит «0» равен 1, бит «1» равен 2 и т. д.) соответствует одному из
 параметров, установленных последовательностью управления режимами заголовка:
 0 Установите метки окон/значков, используя шестнадцатеричный
 1 Запрос подписей к окну/значку в шестнадцатеричном формате
 2 Установите метки окон/значков,
   используя кодировку UTF-8 (дает тот же эффект, что и ресурс utf8Title).
 3 Запрос меток окна/значка с использованием UTF-8
";;
h)load;clear;echo -e "
\e[32m translations\e[0m (class Translations)
 Задает привязки клавиш и кнопок для меню, вариантов выбора,
 «запрограммированных строк» и т. д. Ресурс переводов, обеспечивающий большую
 часть настраиваемости xterm,
 является функцией встроенной библиотеки X Toolkit (Xt). См. раздел «Действия».
";;
j)load;clear;echo -e "
\e[32m trimSelection\e[0m (class TrimSelection)
 Если вы установите highlightSelection, вы сможете увидеть выделенный текст,
 включая все пробелы в конце. Очистка экрана (или строки) сбрасывает его
 в состояние, не содержащее пробелов. Некоторые строки могут содержать пробелы
 в конце, когда приложение выводит их на экран.
 Однако вы можете не захотеть вставлять строки с пробелами в конце.
 Если этот ресурс имеет значение true, xterm будет обрезать конечные пробелы
 в выделенном тексте.
 Это не влияет на пробелы, которые приводят к переносу строки,
 и не обрезает завершающую новую строку из вашего выбора.
";;
i)load;clear;echo -e "
\e[32m underLine\e[0m (class UnderLine)
 Это указывает, должен ли быть подчеркнут текст с атрибутом underline.
 Может быть желательно отключить подчеркивание,
 когда для атрибута подчеркивания используется цвет. The default is “true”.
";;
k)load;clear;echo -e "
\e[32m useBorderClipping\e[0m  (class UseBorderClipping)
 Сообщите xterm, следует ли применять отсечение, если useClipping имеет значение
 false. В отличие от useClipping, это просто ограничивает текст, чтобы он
 оставался в границах окна,
 например, в качестве уточнения обходного пути scaleHeight. The default is “false”.
";;
l)load;clear;echo -e "
 \e[32m useClipping\e[0m (class UseClipping)
 Сообщите xterm, следует ли использовать отсечение, чтобы не создавать точки за
 пределами области рисования текста. Первоначально использовавшийся для обхода
 эффектов зачеркивания, он также необходим для работы с некоторыми шрифтами
 неправильного размера. The default is true.
";;
m)load;clear;echo -e "
\e[32m utf8\e[0m (class Utf8)
 Это указывает, будет ли xterm работать в режиме UTF-8.
 Если вы устанавливаете этот ресурс, xterm также устанавливает ресурс wideChars
 в качестве побочного эффекта. Ресурс можно установить через пункт меню
 «Кодировка UTF-8». По умолчанию стоит «по умолчанию».
 Xterm принимает либо ключевое слово (без учета регистра),
 либо число, указанное в скобках:
\e[32m false   (0)\e[0m Режим UTF-8 изначально выключен. Параметр командной строки
 +u8 устанавливает для ресурса это значение.
 Escape-последовательности для включения/выключения режима UTF-8 разрешены.
\e[32m true    (1)\e[0m Режим UTF-8 изначально включен.
 Escape-последовательности для включения/выключения режима UTF-8 разрешены.
\e[32m always  (2)\e[0m Параметр командной строки -u8 задает для ресурса это значение.
 Escape-последовательности для включения/выключения режима UTF-8 игнорируются.
\e[32m default (3)\e[0m Это значение ресурса по умолчанию. Он изменяется во время
 инициализации в зависимости от того, был ли установлен ресурс локали на false (0)
 или always (2).
 Дополнительные сведения о локалях, отличных от UTF-8, см. в ресурсе по локали.

 Если вы хотите установить значение utf8, оно должно быть в этом диапазоне.
 Другие ненулевые значения обрабатываются так же, как «1», т. е. режим UTF-8
 изначально включен,
 и допускаются escape-последовательности для включения/выключения режима UTF-8.
";;
n)load;clear;echo -e "
\e[32m utf8Fonts\e[0m (class Utf8Fonts)
 См. обсуждение ресурса локали. Это указывает, будет ли xterm использовать
 шрифты UTF-8, указанные с помощью шаблонов ресурсов,
 таких как «*vt100.utf8Fonts.font», или обычные (ISO-8859-1) шрифты с помощью
 шаблонов, таких как «*vt100.font». Ресурс можно установить через пункт меню
 «Шрифты UTF-8». По умолчанию стоит «по умолчанию». Xterm принимает либо ключевое
 слово (без учета регистра), либо число, указанное в скобках:
\e[32m false   (0)\e[0m Используйте шрифты ISO-8859-1. Вход в меню включен,
 что позволяет изменять выбор шрифтов во время выполнения.
\e[32m true    (1)\e[0m Используйте шрифты UTF-8. Вход в меню включен,
 что позволяет изменять выбор шрифтов во время выполнения.
\e[32m always  (2)\e[0m Всегда используйте шрифты UTF-8. Это также отключает вход в меню.
\e[32m default (3)\e[0m При запуске для ресурса устанавливается значение true или false
 в зависимости от действующего значения ресурса utf8.
";;
o)load;clear;echo -e "
\e[32m utf8Latin1\e[0m (class Utf8Latin1)
 Если установлено значение true,
 разрешается комбинировать обычный шрифт ISO-8859-1
 со шрифтом ISO-10646-1, если последний задан с помощью параметра -fw
 или соответствующего значения ресурса. The default is “false”.
";;
p)load;clear;echo -e "
\e[32m utf8SelectTypes\e[0m (class Utf8SelectTypes)
 Переопределите целевой список выбора xterm по умолчанию (см. SELECT/PASTE) для
 выбора в режиме широких символов (UTF-8). По умолчанию используется пустая строка,
 т. е. «», которая ничего не переопределяет.
";;
q)load;clear;echo -e "
\e[32m utf8Title\e[0m (class Utf8Title)
 Приложения могут установить заголовок xterm, написав управляющую последователь-
 ность. Обычно эта управляющая последовательность соответствует соглашению VT220,
 которое кодирует строку в ISO-8859-1 и допускает 8-битный терминатор строки.
 Если xterm запускается в кодировке UTF- 8, он переводит строку ISO-8859-1 в UTF-8
 для работы с библиотеками X, которые предполагают, что строка имеет кодировку UTF-8.
 Однако некоторые пользователи могут захотеть написать строку заголовка в кодировке
 UTF-8. Оконный менеджер отвечает за отрисовку заголовков окон. Некоторые оконные
 менеджеры (не все) поддерживают кодировку UTF-8 заголовков окон. Установите для
 этого ресурса значение «true», чтобы также установить строки заголовков в
 кодировке UTF-8 с помощью свойств EWMH.
 Эта функция доступна в виде пункта меню, поскольку она связана с конкретными
 приложениями, которые вы запускаете в xterm. Вы также можете использовать
 управляющую последовательность (см. обсуждение «Режимов заголовков»
 в Xterm Control Sequences), чтобы установить эквивалентный флаг (который также
 можно установить с помощью ресурса titleModes). Xterm принимает
 либо ключевое слово (без учета регистра), либо число, указанное в скобках:
\e[32m false   (0)\e[0m Установите только строки заголовка ISO-8859-1, например,
 используя свойство ICCCM WM_NAME STRING. Вход в меню включен, что позволяет
 изменять выбор строк заголовков во время выполнения.
\e[32m true    (1)\e[0m Задайте как EWMH (строки UTF-8), так и ICCCM WM_NAME и т. д.
 Пункт меню включен, что позволяет изменить выбор во время выполнения.
\e[32m always  (2)\e[0m Всегда устанавливайте как EWMH (строки UTF-8),
 так и ICCCM WM_NAME и т. д. Это также отключает вход в меню.
\e[32m default (3)\e[0m При запуске для ресурса устанавливается значение true или false
 в зависимости от действующего значения ресурса utf8.
 The default is “default”.
";;
r)load;clear;echo -e "
\e[32m utf8Weblike\e[0m (class Utf8Weblike)
 Предоставьте альтернативную схему обработки ошибок для неправильного формата
 UTF-8, как рекомендовано в документе W3C. Стандарт Unicode не требует этого для
 соответствия. Некоторую дополнительную информацию можно найти здесь:
\e[36m https://invisible-island.net/xterm/bad-utf8/\e[0m
 The default is “false”.
";;
s)load;clear;echo -e "
\e[32m veryBoldColors\e[0m (class VeryBoldColors)
 Указывает, следует ли комбинировать атрибуты видео с цветами, заданными
 параметрами colorBD, colorBL, colorIT, colorRV и colorUL.
 Значение ресурса представляет собой сумму значений для каждого атрибута:
                 1 for reverse,
                 2 for underline,
                 4 for bold,
                 8 for blink, and
                 512 for italic
 The default is “0”.
";;
t)load;clear;echo -e "
\e[32m visualBell\e[0m (class VisualBell)
 Указывает, следует ли использовать видимый звонок (т. е. мигающий) вместо
 звукового звонка при получении Control-G. По умолчанию установлено значение «false»,
 что говорит xterm использовать звуковой сигнал.
";;
u)load;clear;echo -e "
\e[32m visualBellDelay\e[0m (class VisualBellDelay)
 Количество миллисекунд задержки при отображении визуального звонка.
 По умолчанию 100. Если установлено 0, визуальный звонок не отображается.
 Это полезно для очень медленных дисплеев, например, ЖК-дисплея на ноутбуке.
";;
v)load;clear;./nXtermResourcesVT100WidgetI.sh;;
*)
clear
echo -e "\e[33m Неверный ввод данных, пожалуйста повторите ввод \e[0m";;
esac
echo -en "\e[33m Пожалуйста нажмите любую клавишу для продолжения \e[0m"
read -n 1 line
done
clear
