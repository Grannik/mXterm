#!/bin/bash
source "sXterm.sh"
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;30m";}
#
 HEAD()
{
 for (( a=2; a<=38; a++ ))
  do
   TPUT $a 1
        $E "\e[90m\xE2\x94\x82                                                                                \xE2\x94\x82\e[0m";
  done
}
 FOOT()
{
 MARK;
      TPUT  1 1;$E "\e[90m┌────────────────────────────────────────────────────────────────────────────────┐\033[0m";
      TPUT  2 3;$E "\e[1;36mKey Bindings \e[0m\e[36m Привязки клавиш\e[0m";
      TPUT  3 1;$E "\e[90m├────────────────────────────────────────────────────────────────────────────────┤\e[0m";
      TPUT  4 3;$E "\e[36m- 2 -\e[0m";
      TPUT 36 1;$E "\e[90m├─ Up \xE2\x86\x91 \xE2\x86\x93 Down Select Enter ─────────────────────────────────────────────────────┤\e[0m";
      TPUT 39 1;$E "\e[90m└────────────────────────────────────────────────────────────────────────────────┘\033[0m";
 UNMARK;
}
#
  M0(){ TPUT  5 3; $e "Вставляет символ или строку, связанную с нажатой клавишей          \e[32m insert() \e[0m";}
  M1(){ TPUT  6 3; $e "Вставляет восьмибитную версию символа/строки             \e[32m insert-eight-bit() \e[0m";}
  M2(){ TPUT  7 3; $e "Вставьте текущий выбор или данные   \e[32m insert-formatted(format, sourcename []) \e[0m";}
  M3(){ TPUT  8 3; $e "Вставьте данные, скопированные с экрана \e[32m insert-selectable(format, onClicks) \e[0m";}
  M4(){ TPUT  9 3; $e "Вставляет строку, найденную в буфере   \e[32m insert-selection(sourcename [, ...]) \e[0m";}
  M5(){ TPUT 10 3; $e "Это действие является синонимом для вставки              \e[32m insert-seven-bit() \e[0m";}
  M6(){ TPUT 11 3; $e "Интерпретировать управляющую последовательность \e[32m interpret(control-sequence) \e[0m";}
  M7(){ TPUT 12 3; $e "Это действие динамически определяет новую таблицу перевода     \e[32m keymap(name) \e[0m";}
  M8(){ TPUT 13 3; $e "Установите шрифт на следующий больший, исходя из шрифта    \e[32m larger-vt-font() \e[0m";}
  M9(){ TPUT 14 3; $e "Загрузить имена шрифтов из имени/класса/подресурса    \e[32m load-vt-fonts(name[]) \e[0m";}
 M10(){ TPUT 15 3; $e "Изменяет размер окна, чтобы заполнить экран                      \e[32m maximize() \e[0m";}
 M11(){ TPUT 16 3; $e "Действие переключает состояние ресурса metaSendsEscape  \e[32m meta-sends-escape() \e[0m";}
 M12(){ TPUT 17 3; $e "Обработка событий нажатия и отпускания кнопки              \e[32m pointer-button() \e[0m";}
 M13(){ TPUT 18 3; $e "Действие в качестве резерва для обработки событий движения \e[32m pointer-motion() \e[0m";}
 M14(){ TPUT 19 3; $e "Это действие отображает указанное всплывающее меню     \e[32m popup-menu(menuname) \e[0m";}
 M15(){ TPUT 20 3; $e "Это действие печатает окно                             \e[32m print(printer-flags) \e[0m";}
 M16(){ TPUT 21 3; $e "Действие отправляет всю текстовую историю   \e[32m print-everything(printer-flags) \e[0m";}
 M17(){ TPUT 22 3; $e "Отправляет текст текущего окна непосредственно в файл     \e[32m print-immediate() \e[0m";}
 M18(){ TPUT 23 3; $e "Переключает флаг, указывающий xterm                        \e[32m print-on-error() \e[0m";}
 M19(){ TPUT 24 3; $e "Это действие переключает принтерControlMode между 0 и 2       \e[32m print-redir() \e[0m";}
 M20(){ TPUT 25 3; $e "Это действие отправляет SIGHUP в подпрограмму и завершает работу     \e[32m quit() \e[0m";}
 M21(){ TPUT 26 3; $e "Поддерживает необязательную функцию строки чтения         \e[32m readline-button() \e[0m";}
 M22(){ TPUT 27 3; $e "Это действие перерисовывает окно                                   \e[32m redraw() \e[0m";}
 M23(){ TPUT 28 3; $e "Восстанавливает размер окна до его последнего максимизации        \e[32m restore() \e[0m";}
 M24(){ TPUT 29 3; $e "Действие прокручивает текстовое окно назад \e[32m scroll-back(count[units[mouse]]) \e[0m";}
 M25(){ TPUT 30 3; $e "Это действие похоже на прокрутку назад \e[32mscroll-forw(count [,units [,mouse] ]) \e[0m";}
 M26(){ TPUT 31 3; $e "Устанавливает/сбрасывает/переключает внутреннее состояние     \e[32m scroll-lock() \e[0m";}
 M27(){ TPUT 32 3; $e "Прокрутите до заданной строки относительно начала строк    \e[32m scroll-to(count) \e[0m";}
 M28(){ TPUT 33 3; $e "Это действие переключает режим защищенной клавиатуры               \e[32m secure() \e[0m";}
 M29(){ TPUT 34 3; $e "Это действие похоже на select-end       \e[32m select-cursor-end(destname [, ...]) \e[0m";}
 M30(){ TPUT 35 3; $e "Это действие похоже на select-extend                 \e[32m select-cursor-extend() \e[0m";}
#
 M31(){ TPUT 37 3; $e "Далее                                                                  \e[32m Next \e[0m";}
 M32(){ TPUT 38 3; $e "Выход                                                                  \e[32m Exit \e[0m";}
LM=32
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 Это действие вставляет символ или строку, связанную с нажатой клавишей.
\e[32m insert()\e[0m
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
    Это действие вставляет восьмибитную (мета) версию символа или строки,
 связанную с нажатой клавишей. Специально обрабатываются только однобайтовые
 значения. Точное действие зависит от значения ресурсов altSendsEscape и
 metaSendsEscape, а также восьмиBitInput. Сначала тестируется ресурс
 metaSendsEscape. Полное обсуждение см. в ресурсе sixBitInput.
 Термин «восьмибитный» вводит в заблуждение: xterm проверяет,
 находится ли ключ в диапазоне от 128 до 255 (установлен восьмой бит).
 Если значение находится в этом диапазоне, в зависимости от значений ресурсов,
 xterm может выполнить одно из следующих действий:
  • добавить к значению 128, установив его восьмой бит,
  • послать байт ESC перед ключом, или
  • отправить ключ без изменений.
\e[32m insert-eight-bit()\e[0m
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 Вставьте текущий выбор или данные, связанные с ним, отформатированные.
 Первый параметр, формат, дает шаблон для данных, как в формате exec.
 Последующие параметры указывают источник выбора, как в выборе вставки.
\e[32m insert-formatted(format, sourcename [, ...])\e[0m
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 Вставьте данные, скопированные с экрана, отформатированные.
 Первый параметр, формат, дает шаблон для данных, как в формате exec.
 Второй параметр указывает метод копирования данных, как в ресурсе on2Clicks.
\e[32m insert-selectable(format, onClicks)\e[0m
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 Это действие вставляет строку, найденную в выделенном буфере или буфере вырезания
 указанном в параметре sourcename. Источники проверяются в указанном порядке
 (регистр имеет значение), пока не будет найден один из них. Обычно используемые
 варианты выбора включают: ОСНОВНОЙ, ВТОРИЧНЫЙ и БУФЕР ОБМЕНА.
 Буферы вырезания обычно называются от CUT_BUFFER0 до CUT_BUFFER7.
\e[32m insert-selection(sourcename [, ...])\e[0m
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 Это действие является синонимом для вставки(). Термин «семибитный» вводит в
 заблуждение: он означает только то, что xterm не пытается добавить 128
 к значению ключа, как в методе insert-eight-bit()
\e[32m insert-seven-bit()\e[0m
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Интерпретировать заданную управляющую последовательность локально, т. е. без
 передачи ее хосту. Это работает путем вставки управляющей последовательности в
 начало входного буфера. Используйте «\\», чтобы экранировать восьмеричные цифры
 в строке. Xt не позволяет помещать в строку нулевой символ (например, «\\000»).
\e[32m interpret(control-sequence)\e[0m
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Это действие динамически определяет новую таблицу перевода, имя ресурса которой
 — name с суффиксом «Keymap» (т. е. nameKeymap, где регистр имеет значение).
 Имя None восстанавливает исходную таблицу перевода.
\e[32m keymap(name)\e[0m
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Установите шрифт на следующий больший, исходя из размеров шрифта.
 See also set-vt-font().
\e[32m larger-vt-font()\e[0m
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 Загрузить имена шрифтов из заданного имени и класса подресурса.
 То есть загрузите «*VT100.name.font», ресурс как «*VT100.font» и т. д.
 Если имя не указано, восстанавливается исходный набор имен шрифтов.
 В отличие от set-vt-font(), это не влияет на escape- и select-шрифты,
 поскольку они не основаны на значениях ресурсов.
 Это влияет на шрифты, свободно организованные в пункте меню «По умолчанию»,
 включая шрифт, полужирный шрифт, широкий шрифт и широкий жирный шрифт.
\e[32m load-vt-fonts(name[,class])\e[0m
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 Изменяет размер окна, чтобы заполнить экран.
\e[32m maximize()\e[0m
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие переключает состояние ресурса metaSendsEscape.
\e[32m meta-sends-escape()\e[0m
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 Используйте это действие в качестве резерва для обработки событий нажатия и
 отпускания кнопки для протокола последовательности управления мышью, когда
 переводы, связанные с выбором, подавляются с помощью ресурса omitTranslation.
\e[32m pointer-button()\e[0m
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
 Используйте это действие в качестве резерва для обработки событий движения для
 протокола последовательности управления мышью, когда переводы, связанные
 с выбором, подавляются с помощью ресурса omitTranslation.
\e[32m pointer-motion()\e[0m
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие отображает указанное всплывающее меню.
 Допустимые имена (регистр важен) включают:
 mainMenu, vtMenu, fontMenu, and tekMenu
\e[32m popup-menu(menuname)\e[0m
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие печатает окно. Он также вызывается записью печати в mainMenu.
 Действие принимает необязательные параметры, которые временно переопределяют
 параметры ресурса. Значения параметров сопоставляются без учета регистра:
\e[32m noFormFeed\e[0m еревод формы не будет отправлен в конце последней напечатанной строки
 (т. е. для принтераFormFeed установлено значение false).
\e[32m FormFeed\e[0m перевод формы будет отправлен в конце последней напечатанной строки
 (i.e., printerFormFeed is “true”)
\e[32m noNewLine\e[0m в конце последней напечатанной строки не будет отправляться
 новая строка, а строки с переносом будут объединены в длинные строки
 (i.e., printerNewLine is “false”)
\e[32m NewLine\e[0m новая строка будет отправлена в конце последней напечатанной строки,
 и каждая строка будет ограничена (путем добавления новой строки) шириной экрана
 (i.e., printerNewLine is “true”).
\e[32m noAttrs\e[0m страница печатается без атрибутов (i.e., printAttributes is “0”)
\e[32m monoAttrs\e[0m страница печатается с монохромными (vt220) атрибутами
 (i.e., printAttributes is “1”)
\e[32m colorAttrs\e[0m страница печатается с цветовыми атрибутами ANSI
 (i.e., printAttributes is “2”)
";ES;fi;;
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие отправляет всю текстовую историю, в дополнение к отображаемому в
 данный момент тексту, в программу, указанную в ресурсе printerCommand.
 Он допускает те же необязательные параметры, что и действие печати.
 С помощью подходящей команды принтера это действие можно использовать
 для загрузки текстовой истории в редакторе.
\e[32m print-everything(printer-flags)\e[0m
";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;echo -e "
 Отправляет текст текущего окна непосредственно в файл, как указано в ресурсах
 printFileImmediate, printModeImmediate и printOptsImmediate.
\e[32m print-immediate()\e[0m
";ES;fi;;
 18) S=M18;SC;if [[ $cur == enter ]];then R;echo -e "
 Переключает флаг, указывающий xterm, что если он завершается с ошибкой X,
 текст текущего окна отправляется непосредственно в файл, как указано в ресурсах
 printFileOnXError, printModeOnXError и printOptsOnXError.
\e[32m print-on-error()\e[0m
";ES;fi;;
 19) S=M19;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие переключает принтерControlMode между 0 и 2.
 Соответствующий пункт всплывающего меню полезен для выключения принтера,
 если вы вдруг передумали после того,
 как решили печатать случайные двоичные файлы на терминале.
\e[32m print-redir()\e[0m
";ES;fi;;
 20) S=M20;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие отправляет SIGHUP в подпрограмму и завершает работу.
 Он также вызывается записью quit в mainMenu.
\e[32m \e[32m quit()\e[0m
";ES;fi;;
 21) S=M21;SC;if [[ $cur == enter ]];then R;echo -e "
 Поддерживает необязательную функцию строки чтения, повторяя повторяющиеся
 управляющие последовательности курсора вперед или назад при событии отпускания
 кнопки, чтобы запросить, чтобы хост-приложение обновило свое представление о
 позиции курсора, чтобы оно соответствовало событию кнопки.
\e[32m readline-button()\e[0m
";ES;fi;;
 22) S=M22;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие перерисовывает окно.
 Он также вызывается записью перерисовки в mainMenu.
\e[32m redraw()\e[0m
";ES;fi;;
 23) S=M23;SC;if [[ $cur == enter ]];then R;echo -e "
 Восстанавливает размер окна до его последнего максимизации.
\e[32m restore()\e[0m
";ES;fi;;
 24) S=M24;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие прокручивает текстовое окно назад, так что текст, который ранее
 прокручивался за пределы верхней части экрана, теперь виден.
 Аргумент count указывает количество единиц (которые могут быть страницей,
 половиной страницы, пикселем или строкой), на которые следует прокручивать.
 Если параметр count не указан,
 xterm использует количество строк, заданное ресурсом scrollLines.
 Корректировка может быть указана для единиц страницы или половины страницы
 путем добавления знака «+» или «-», за которым следует число, например,
 страница-2, чтобы указать на 2 строки меньше, чем страница.
 Если второй параметр опущен, используются «линии». Если указан третий
 параметр мыши, действие игнорируется, если включен отчет о мыши.
\e[32m scroll-back(count [,units [,mouse] ])\e[0m
";ES;fi;;
 25) S=M25;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие похоже на прокрутку назад,
 за исключением того, что оно прокручивается в другом направлении.
\e[32m scroll-forw(count [,units [,mouse] ])\e[0m
";ES;fi;;
 26) S=M26;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие устанавливает, сбрасывает или переключает внутреннее состояние,
 которое сообщает xterm, активна ли Scroll Lock,
 в зависимости от ресурса allowScrollLock.
\e[32m scroll-lock(on/off/toggle)\e[0m
";ES;fi;;
 27) S=M27;SC;if [[ $cur == enter ]];then R;echo -e "
 Прокрутите до заданной строки относительно начала сохраненных строк. Например,
 «scroll-to(0)» будет прокручивать до начала.
 Распознаются два специальных нечисловых параметра:
\e[32m scroll-to(begin)\e[0m Прокрутите до начала сохраненных строк.
\e[32m scroll-to(end)  \e[0m
 Прокрутите до конца сохраненных строк, т. е. до текущей активной страницы.
\e[32m scroll-to(count)\e[0m
";ES;fi;;
 28) S=M28;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие переключает режим защищенной клавиатуры (см. БЕЗОПАСНОСТЬ)
 и вызывается из записи securekbd в mainMenu.
\e[32m secure()\e[0m
";ES;fi;;
 29) S=M29;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие похоже на select-end, за исключением того,
 что его следует использовать с select-cursor-start.
\e[32m select-cursor-end(destname [, ...])\e[0m
";ES;fi;;
 30) S=M30;SC;if [[ $cur == enter ]];then R;echo -e "
 Это действие похоже на select-extend, за исключением того,
 что его следует использовать с select-cursor-start.
\e[32m select-cursor-extend()\e[0m
";ES;fi;;
#
 31) S=M31;SC;if [[ $cur == enter ]];then R;./kXtermKeyBindingsC.sh;ES;fi;;
 32) S=M32;SC;if [[ $cur == enter ]];then R;clear;exit 0;fi;;
 esac;POS;done
