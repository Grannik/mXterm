#!/bin/bash
sleep 0.1;echo "
┌────────────────────────────────────────────────────────────────────────────────┐"
sleep 0.1;echo -e "
\e[1;36m Select/Paste \e[0m\e[36m Выделить/вставить\e[0m"
sleep 0.1;echo "
 X-клиенты обеспечивают поддержку выбора и вставки, отвечая на запросы, переданные
 X-сервером. X-сервер хранит данные в «атомах», которые соответствуют различным
 типам выделения (PRIMARY, SECONDARY, CLIPBOARD), а также аналогичному механизму
 буфера вырезания (CUT_BUFFER0 — CUT_BUFFER7). Они задокументированы в ICCCM.
 ICCCM имеет дело с базовым механизмом выбора/вставки.
 В нем не упоминается подсветка. Выбор не то же самое, что выделение.
 Xterm (как и многие приложения) использует подсветку, чтобы показать вам
 выделенный в данный момент текст.
 Приложение X может владеть выделенным фрагментом, что позволяет ему быть
 источником данных, скопированных с использованием заданного атома выделенного
 фрагмента. Xterm может продолжать владеть выделенным фрагментом после прекращения
 выделения (см. KeepSelection).
"
sleep 0.1;echo -e "\e[32m PRIMARY\e[0m НАЧАЛЬНЫЙ
  При настройке на использование основного выбора (по умолчанию) xterm может
 предоставлять данные выбора способами, которые помогают сохранить информацию
 о кодировке символов при ее вставке.
  Токен PRIMARY — это стандартная функция X, описанная в ICCCM (Руководстве по
 межклиентским коммуникациям), в котором говорится:
  Выбор, названный атомом PRIMARY, используется для всех команд, которые принимают
 только один аргумент, и является основным средством связи между клиентами,
 использующими механизм выбора.
  Пользователь «выбирает» текст в xterm, который выделяет выбранный текст.
 Последующая «вставка» другому клиенту перенаправляет запрос клиенту, владеющему
 выбором. Если xterm владеет первичным выбором, он делает данные доступными в виде
 одной или нескольких «целей выбора». Если он не владеет первичным выбором,
 например, если он освободил его или другой клиент подтвердил право собственности,
 он полагается на буферы вырезания для передачи данных. Но cut-buffers обрабатывают
 только данные ISO-8859-1 (официально — некоторые клиенты игнорируют правила).
"
sleep 0.1;echo -e "\e[32m CLIPBOARD\e[0m БУФЕР ОБМЕНА
 При настройке на использование буфера обмена (используя ресурс selectToClipboard)
 проблема с сохранением права собственности обходится. В противном случае нет
 никакой разницы в отношении данных, которые могут быть переданы посредством выбора.
 Ресурс selectToClipboard представляет собой компромисс, позволяющий обращаться с
 БУФЕРОМ ОБМЕНА почти как с ПЕРВИЧНЫМ, в отличие от ICCCM, который описывает
 БУФЕР ОБМЕНА в терминах, отличных от ПЕРВИЧНОГО или ВТОРИЧНОГО.
 Его длинное объяснение начинается с основных моментов:
 Выделение, названное атомом CLIPBOARD, используется для хранения данных, которые
 передаются между клиентами, т. е. данных, которые обычно вырезаются, а затем
 вставляются или копируются, а затем вставляются.
 Всякий раз, когда клиент хочет передать данные в буфер обмена:
 • Он должен утверждать право собственности на БУФЕР ОБМЕНА.
 • Если ему удастся получить право собственности, он должен быть готов ответить
 на запрос содержимого БУФЕРА ОБМЕНА обычным способом (сохранив данные, чтобы
 иметь возможность их вернуть).
 Запрос может быть сгенерирован клиентом буфера обмена, описанным ниже.
"
sleep 0.1;echo -e "\e[32m SELECT\e[0m ВЫБРАТЬ
 Однако многие приложения используют CLIPBOARD, имитируя другие оконные системы.
 Ресурс selectToClipboard (и соответствующий пункт меню Select to Clipboard)
 представляет маркер SELECT (известный только xterm),
 который выбирает между маркерами PRIMARY и CLIPBOARD.
 Без использования этой функции можно использовать обходные пути, такие как
 программа xclip, для отображения содержимого буфера обмена X в окне xterm.
"
sleep 0.1;echo -e "\e[32m SECONDARY\e[0m ВТОРИЧНЫЙ
 Используется реже, чем PRIMARY или CLIPBOARD. Согласно ICCCM, он используется
 • В качестве второго аргумента для команд, принимающих два аргумента (например,
   «поменять местами первичный и вторичный выбор»)
 • Как средство получения данных, когда есть первичный выбор и пользователь
   не хочет его нарушать
"
sleep 0.1;echo -e "\e[32m Selection Targets\e[0m Цели выбора
 Различные типы передаваемых данных зависят от того, что запрашивает принимающий
 клиент. Они называются целями отбора.
 При запросе данных выбора xterm пробует следующие типы в следующем порядке:
\e[32m UTF8_STRING\e[0m Это расширение XFree86, означающее, что данные
 закодированы в UTF-8. Когда xterm построен с поддержкой расширенных символов,
 он одновременно принимает и предоставляет этот тип.
\e[32m TEXT\e[0m текст находится в кодировке, соответствующей вашей текущей локали.
\e[32m COMPOUND_TEXT\e[0m это формат для данных с несколькими наборами символов,
 таких как многоязычный текст.
 В качестве особого случая он может хранить данные UTF-8.
"
sleep 0.1;echo -e "\e[32m STRING\e[0m строка Это данные Latin 1 (ISO-8859-1).
"
sleep 0.1;echo " Два средних (TEXT и COMPOUND_TEXT) добавляются, если xterm настроен с ресурсом
 i18nSelections, установленным на «true».
  UTF8_STRING является предпочтительным (поэтому первым в списке), так как xterm
 сохраняет текст как данные Unicode при работе в режиме расширенных символов, и
 перевод не требуется. С другой стороны, TEXT и COMPOUND_TEXT могут потребовать
 перевода. Если перевод неполный, они вставят X «defaultString», значение которого
 не может быть установлено и может быть просто пустым. Ресурс Xterm defaultString
 указывает строку, используемую для неполных переводов UTF8_STRING.
   Вы можете изменить типы, которые xterm пытается использовать, используя ресурсы
 восемьBitSelectTypes или utf8SelectTypes. Например, у вас может быть определенная
 настройка локали, которая не использует кодировку UTF-8. Значение ресурса
 представляет собой список целей выбора, разделенных запятыми, которые состоят из
 показанных имен. Вы можете использовать специальное имя I18N для обозначения
 необязательного включения TEXT и COMPOUND_TEXT. Имена сопоставляются без учета
 регистра и могут быть сокращены.
 Список по умолчанию может быть выражен несколькими способами, например,
 UTF8_STRING,I18N,STRING
 utf8,i18n,string
 u,i,s
"
sleep 0.1;echo -e "\e[32m Mouse Protocol\e[0m Протокол мыши
 Приложения могут отправлять escape-последовательности в xterm, чтобы заставить
 его отправлять escape-последовательности обратно на компьютер при нажатии кнопки
 указателя или даже (в зависимости от того, какая escape-последовательность) от-
 правлять escape-последовательности обратно на компьютер при перемещении указателя.
  Эти escape-последовательности и ответы, называемые протоколом мыши,
 задокументированы в XTerm Control Sequences. Они не отображаются в действиях,
 вызываемых ресурсом переводов, потому что ресурс не изменяется при запуске xterm,
 тогда как приложения могут изменять протокол мыши (т. е. включать, отключать,
 использовать разные режимы).
  Однако протокол мыши интерпретируется в действиях, которые обычно связаны с
 кнопками указателя. Xterm игнорирует протокол мыши в действии выбора вставки,
 если одновременно нажата клавиша Shift. Он также изменяет несколько других
 действий, если нажата клавиша Shift, например, подавляет ответ с положением
 указателя, но не устраняет изменения в выделенном тексте."
sleep 0.1;echo "
└────────────────────────────────────────────────────────────────────────────────┘
"
