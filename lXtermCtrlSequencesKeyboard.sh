#!/bin/bash
sleep 0.1;echo "
┌────────────────────────────────────────────────────────────────────────────────┐"
sleep 0.1;echo -e "
\e[1;36m Control Sequences and Keyboard \e[0m\e[36m Последовательности управления и клавиатура\e[0m
"
sleep 0.1;echo "
 Приложения могут отправлять последовательности символов на терминал,
 чтобы изменить его поведение.
 Часто их называют «управляющими последовательностями ANSI» или
 просто «управляющими последовательностями», но оба термина вводят в заблуждение:
 • Стандарт ANSI x3.64 (устаревший), который был заменен стандартом ISO 6429
 (ECMA-48), содержит правила для формата этих последовательностей символов.
 • Хотя заявлено, что исходный VT100 совместим со стандартом ANSI
 (по сравнению с x3.64), в свободном доступе нет версии стандарта ANSI,
 показывающей, чем отличается VT100.
 Большинство документов, в которых упоминается стандарт ANSI, содержат дополнения,
 отсутствующие в оригинале (например, основанные на ansi.sys).
 Таким образом, это обсуждение сосредоточено на стандартах ISO.
 • Стандарт описывает только последовательности, отправляемые с хоста на терминал.
 Не существует стандарта для последовательностей, отправляемых специальными
 клавишами с терминала на хост.
 По соглашению (и со ссылкой на существующие терминалы) формат этих
 последовательностей обычно соответствует стандарту хост-терминал.
 • Некоторые последовательности xterm не вписываются в стандартную схему.
 Технически они «не указаны». Например, DEC Screen Alignment Test (DECALN)
 представляет собой последовательность из трех символов:
 ESC # 8
 • Некоторые последовательности соответствуют стандартному формату,
 но не указаны в стандарте. К ним относятся последовательности,
 используемые для настройки полей прокрутки и прокрутки вперед/назад.
 • Некоторые последовательности (в частности, односимвольные функции,
 такие как табуляция и возврат) не включают escape-символ.
 Имея все это в виду, стандарт называет эти последовательности символов
 «управляющими последовательностями».
 В Xterm Control Sequences перечислены управляющие последовательности,
 которые приложение может отправлять xterm для выполнения различных операций.
 Большинство этих операций стандартизированы либо на терминалах DEC или Tektronix,
 либо на основе более широко используемых стандартов, таких как ISO-6429.
 В этом разделе приведены несколько примеров использования.
"
sleep 0.1;echo -e "\e[32m Window and Icon Titles\e[0m Заголовки окон и значков Некоторые скрипты используют
 echo с опциями -e и -n, чтобы указать оболочке интерпретировать строку «\\ e»
 как escape-символ и подавить завершающую новую строку при выводе.
 Они не переносимы и не рекомендуются. Вместо этого используйте printf (POSIX).
 Например, чтобы установить заголовок окна «Hello world!»,
 вы можете использовать одну из этих команд в сценарии:
"
cat tXtermControlSequencesAndKeyboard.txt
sleep 0.1;echo -e "\e[32m Special Keys\e[0m Специальные клавиши
 Xterm, как и любой VT100-совместимый эмулятор терминала, имеет два режима для
 специальных клавиш (клавиши курсора, цифровая клавиатура
 и некоторые функциональные клавиши):
 • нормальный режим, в котором специальные клавиши передают «полезные»
 последовательности, такие как управляющая последовательность для перемещения
 курсора вверх при нажатии стрелки вверх и
 • прикладной режим, в котором используется другая последовательность управления,
 которую нельзя спутать с «полезной» последовательностью.
   Основное различие между этими двумя режимами заключается в том,
 что последовательности в обычном режиме начинаются с CSI (экранирование [),
 а последовательности прикладного режима начинаются с SS3 (экранирование O).
   Терминал инициализируется в один из этих двух режимов (обычно обычный режим)
 на основе описания терминала (termcap или terminfo).
   В описании терминала также есть возможности (строки),
 определенные для режима клавиатуры, используемого в приложениях curses.
   Существует проблема с использованием описания терминала для приложений,
 которые не предназначены для использования в полноэкранном режиме curses:
 определения специальных клавиш верны только для этого режима клавиатуры.
 Например, некоторые оболочки (в отличие от ksh(1), который выглядит жестко
 запрограммированным, даже без использования termcap) позволяют своим
 пользователям настраивать привязки клавиш,
 назначая действия оболочки специальным клавишам.
 • bash(1) позволяет назначать константные строки функциям.
 Это возможно только в том случае, если терминал по умолчанию инициализирован
 в режиме приложения, потому что в этой области bash не хватает гибкости.
 Он использует (менее выразительный, чем bash) язык сценариев readline
 для настройки привязок клавиш, который полагается на то, что пользователь
 статически перечисляет возможные привязки для заданных значений \$TERM.
 • zsh(1) предоставляет аналогичную функцию, но принимает выражения времени
 выполнения, а также предоставляет массив \$terminfo для скриптов.
 В частности, можно использовать терминальную базу данных, трансформируясь при
 определении привязки клавиш. Преобразовав выходные данные так, чтобы CSI и SS3
 были приравнены, zsh может использовать базу данных терминала для получения
 полезных определений для использования в командной строке независимо от того,
 использует ли терминал обычный режим или режим приложения изначально. Вот пример:"
sleep 0.1;echo -e "\e[32m
               [[ \"\$terminfo[kcuu1]\" == \"^[O\"* ]] && \\
               bindkey -M viins \"\${terminfo[kcuu1]/O/[}\" \\
               vi-up-line-or-history
\e[0m"
sleep 0.1;echo -e "\e[32m Changing Colors\e[0m Изменение цвета
 Несколько программ оболочки предоставляют пользователям возможность добавлять
 цвет и другие атрибуты видео в строки приглашения оболочки.
 Пользователи могут сделать это, установив \$PS1 (основная строка приглашения).
 Опять же, bash и zsh предоставили функции, которых нет в ksh.
 Однако есть проблема: ширина подсказки на экране не обязательно будет равна
 количеству символов. Поскольку в стандарте POSIX нет указаний,
 каждая оболочка решает проблему по-своему:
 • bash обрабатывает символы внутри “\\[” and “\\]”
   как непечатаемые (не используя ширину экрана).
 • zsh обрабатывает символы в пределах “%{” and “%}” как непечатаемые.
 Помимо разницы в синтаксисе, оболочки предоставляют разные методы получения
 полезных управляющих последовательностей:
 • Как отмечено в разделе «Специальные ключи»,
 zsh инициализирует массив \$terminfo возможностями терминала.
 Он также предоставляет функцию echoti, которая работает подобно tput
 для преобразования возможности терминала с ее параметрами в строку,
 которую можно записать на терминал.
 • Оболочки, не имеющие сопоставимой функции (например, bash),
 всегда могут использовать программу tput для выполнения этого преобразования.
 Жестко закодированные управляющие последовательности поддерживаются каждой
 оболочкой, но не рекомендуются, поскольку они зависят от конкретных конфигураций
 и не могут быть легко перемещены между различными пользовательскими средами.
"
sleep 0.1;echo "
└────────────────────────────────────────────────────────────────────────────────┘
"
